7755A285	Some key ideas originating in the domain of software technology have been used in the design of the architecture description language S*M.
7A36F8DB	From the viewpoint of software engineering implementation, a MDA-based development approach for software mining systems is proposed in this paper. The development process starts from the describing of platform independent models. Then, by tightly integrating different functional modules such as storage management, data preprocessing, mining operations and mining base management, the approach succeeds in transforming models between different levels. This approach may not only be a theoretical guidance for model transformation, but also can be a measurement for validating the mapping rules between models at different abstract levels of the same system, and thus can make an effect support to model driven software engineering.
7AC6606E	Conventional wisdom suggests that a software system's architecture has a significant impact on its evolution. Prior research has studied the evolution of software using the information of how its files have changed together in their revision history. No prior study, however, has investigated the impact of architecture on the evolution of software from its change history. This is mainly because most open-source software systems do not document their architectures. We have overcome this challenge using several architecture recovery techniques. We used the recovered models to examine if co-changes spanning multiple architecture modules are more likely to introduce bugs than co-changes that are within modules. The results show that the co-changes that cross architectural module boundaries are more correlated with defects than co-changes within modules, implying that, to improve accuracy, bug predictors should also take the software architecture of the system into consideration.
7D5F3DA7	This paper introduces the PARSA (PARallel program Scheduling and Assessment) parallel software development tool to address the efficient partitioning and scheduling of parallel programs on multiprocessor systems. The PARSA environment consists of a user-friendly (visual), interactive, compile-time environment for partitioning, scheduling, and performance evaluation/tuning of parallel programs on different parallel computer architectures.
772D9D7E	This paper deals with distributed multiagent reconfigurable embedded-control systems following the component-based International Industrial Standard IEC61499 in which a function block (FB) is an event-triggered software component owning data and a control application is a distributed network of FBs. We define an architecture of reconfigurable multiagent systems, where a reconfiguration agent modeled by nested state machines is affected to each device of the execution environment to apply local automatic reconfigurations, and a coordination agent is proposed for any coordination between devices in order to guarantee safe and adequate distributed reconfigurations. A communication protocol is proposed in our research to handle coordinations between agents by using well-defined coordination matrices. We define, in addition, Extensible Markup Language (XML) based implementations for both kinds of agents, where XML code blocks are exchanged between devices. The contributions of the paper are applied to two benchmark production systems available in our laboratory.
7F3F3936	Unique characteristics of biological systems are described, and similarities are made to certain computing architectures. The security challenges posed by these characteristics are discussed. A method of securely isolating portions of a design using introspective capabilities of a fine-grain self-configurable device is presented. Experimental results are discussed, and plans for future work are given.
7F26E2C0	Software architecture describes the structure of a system, enabling more effective design, program understanding, and formal analysis. However, existing approaches decouple implementation code from architecture, allowing inconsistencies, causing confusion, violating architectural properties, and inhibiting software evolution. ArchJava is an extension to Java that seamlessly unifies software architecture with implementation, ensuring that the implementation conforms to architectural constraints. A case study applying ArchJava to a circuit-design application suggests that ArchJava can express architectural structure effectively within an implementation, and that it can aid in program understanding and software evolution.
7F1249D2	An architecture-independent software development approach for parallel processing systems is presented. This approach is based on the parallel object oriented and functional computation model PROOF and separates the architecture dependent issues from software development. It also facilitates software development for any parallel processing systems by relieving the programmers from the consideration of processor topology and various parallelization aspects of the software. Our approach allows the exploitation of parallelism at both levels of granularity: object level and method level, thereby making our approach effective for software development for various MIMD computers. Software developed using our approach reflects the parallel structure of the problem space which makes the software more understandable and modifiable. A framework consisting of object-oriented analysis, object-design, coding and transformation phases is presented for software development for parallel processing systems. An example is given to illustrate this approach.
765D6FA7	Content Management Systems are commonly used to develop web portals and virtual communities. Many of these systems are built using a multitier architecture approach for both the framework and the modules to provide the portal's functionalities. However, expanding upon these systems through creating or purchasing new modules can be challenging and inefficient. Large development teams are susceptible to a lost in productivity due to modular inter-dependencies. And smaller teams may struggle to manage the portal's growth or to provide users with reliable functionality. The challenges associated with modular software are examined in this paper through the analysis of the construction of an active virtual community: ProjectSTEM.net. Based on these observations, a method for developing custom software using multitier architecture is introduced. In this study, this method was found to increase the productivity of the development team, the functional reliability of the software and the commercial viability of the modules. The method was also found to decrease the storage needs for the systems and facilitate easier migration of data if the portal was to be moved to another platform.
79ED41AD	Software architectures have the potential to substantially improve the development and evolution of large, complex, multi-lingual, multi-platform, long-running systems. However, in order to achieve this potential, specific techniques for architecture-based modeling, analysis, and evolution must be provided. Furthermore, one cannot fully benefit from such techniques unless support for mapping an architecture to an implementation also exists. This paper motivates and presents one such approach, which is an outgrowth of our experience with systems developed and evolved according to the C2 architectural style. We describe an architecture description language (ADL) specifically designed to support architecture-based evolution and discuss the kinds of evolution the language supports. We then describe a component-based environment that enables modeling, analysis, and evolution of architectures expressed in the ADL, as well as mapping of architectural models to an implementation infrastructure. The architecture of the environment itself can be evolved easily to support multiple ADLs, kinds of analyses, architectural styles, and implementation platforms. Our approach is fully reflexive: the environment can be used to describe, analyze, evolve, and (partially) implement itself, using the very ADL it supports. An existing architecture is used throughout the paper to provide illustrations and examples.
8164D439	A packaging system that allows diverse software components to be easily interconnected within heterogeneous programming environments is described. Interface software and stubs are generated for programmers automatically once the programmers express their application's geometry in a few simple rules and module interconnection language attributes. By generating custom interface code for each application, based on analysis and extraction of interfacing requirements, the system is able to produce executables whose run-time performance is comparable to manually integrated applications. The system is implemented within the Unix environment.
815C5F85	The configuration complexity of preproduction sites coupled with access-control mechanisms often impede the software development life cycle. Virtualization is a cost-effective way to remove such barriers and provide a test environment similar to the production site, reducing the burden in IT administrators. An eclipse-based virtualization tool framework can offer developers a personal runtime environment for launching and testing their applications. The authors have followed a model-driven architecture (MDA) approach that integrates best-of-breed virtualization technologies, such as Xen and VDE.
7FC9497C	While a large fraction of application code is devoted to graphical user interface (GUI) functions, support for reuse in this domain has largely been confined to the creation of GUI toolkits ("widgets"). We present a novel architectural style directed at supporting larger grain reuse and flexible system composition. Moreover, the style supports design of distributed, concurrent applications. Asynchronous notification messages and asynchronous request messages are the sole basis for intercomponent communication. A key aspect of the style is that components are not built with any dependencies on what typically would be considered lower-level components, such as user interface toolkits. Indeed, all components are oblivious to the existence of any components to which notification messages are sent. While our focus has been on applications involving graphical user interfaces, the style has the potential for broader applicability. Several trial applications using the style are described.
808999EB	Modern concurrent and distributed applications are becoming increasingly complex; so, in order to provide fault tolerance, special structuring mechanisms are required to help reduce this complexity. Unfortunately, such structuring techniques are mostly introduced as design and implementation features, which complicates their employment. The approach we propose relies on introducing the appropriate software structuring together with associated fault tolerance measures at the earlier phases of software development and on supporting it with special software architectures and design patterns.
80219DBE	Software development environments (SDEs) are examined from the environment architect's perspective. The main interest is in investigating two related issues of building SDEs: open architecture and tool integration. A taxonomy of architectural mechanisms that solely determine the underlying architecture of an SDE is presented. The significance of this taxonomy is that it makes it possible to study the intrinsic properties of SDE architecture with respect to technical issues such as portability, tool integration, tool construction, tailorability, and evolution of SDEs. Four types of mechanisms are identified: modeling and schema-definition mechanisms, access mechanisms, interprocess communication mechanisms, and execution mechanisms. These four types of mechanisms reflect the relationship of tools to the SDE architecture. For each type of mechanism, various approaches proposed in the literature are compared and openness and integration are discussed. It is suggested that truly open and integrated SDEs can be achieved through careful selection of architectural mechanisms and good implementation strategies of these mechanisms.
7DEDA25C	To maintain and understand large applications, it is crucial to know their architecture. The first problem is that unlike classes and packages, architecture is not explicitly represented in the code. The second problem is that successful applications evolve over time, so their architecture inevitably drifts. Reconstructing the architecture and checking whether it is still valid is therefore an important aid. While there is a plethora of approaches and techniques supporting architecture reconstruction, there is no comprehensive state of the art and it is often difficult to compare the approaches. This article presents a state of the art on software architecture reconstruction approaches
7A80B7F9	We're happy to get on the road with the column. Be aware that you may be carrying 100 million lines of code with you the next time you take the car. Jiirgen Moessinger is vice president for automotive systems integration at Bosch and describes the challenges and opportunities that software brings to the automotive industry.
0FC2B3F6	The data acquisition system for loadcell calibration has been upgraded from a dedicated instrument controller to a desktop computer with a Microsoft(registered) WIN95 operating system. This paper includes a discussion of the selection of the instrumentation, software, design of the switching network, and software development. The system is controlled and monitored by software developed using National Instruments graphical programming language, LabVIEW. Data reports are generated in Microsoft Excel using Object Linking and Embedding (OLE) routines from LabVIEW. Data are archived in Microsoft Access with OLE routines from LabVIEW. Reports and historical data are electronically available to the test facilities at Arnold Engineering Development Center (AEDC) over the base Intranet.
7D729C18	Modern software frameworks provide a set of commonand prefabricated software artifacts that supportengineers in developing large-scale software systems.Framework-related information can be implemented insource code, comments or configuration files, but in thelatter two cases, current reverse engineering approachesmiss important facts reducing the quality of subsequentanalysis tasks. We introduce a generic fact extractionapproach for framework-based systems by combiningtraditional parsing with lexical pattern matching toobtain framework-specific facts from all three sources.We evaluate our approach with an industrial softwareapplication that was built using the Avalon/Phoenixframework. In particular we give examples to point outthe benefits of considering framework-related informationand reflect experiences made during the case study.
7F726C81	A cooperative system architecture is proposed for systemization of scheduling work, taking account of the desirable relationship between an expert and a computer. The architecture emphasizes the significance of a system structure in which decision-making and trial operation can be easily performed by the expert and the system can simulate the expert's intentions. Since an expert expresses his intentions mainly by mouse operations, using only a narrow bandwidth of communication from a human to a computer, the authors propose that domain knowledge should be used to grasp the expert's intentions. The load-balancing problem is analyzed and an example is given that shows such a problem is cooperatively solved by the InterBALANCE system.
7ED8344D	OMG’s Model Driven Architecture (MDA) has deeply influenced modern-day software development, not only by providing promising means for automating the software process, but also through revitalizing the role of modeling in software development, the importance of which had been neglected during the recent euphoria over lightweight development methods. However, MDA’s need to remain reasonably abstract means that it is more a software development approach rather than a standalone methodology, and therefore needs methodology support to be practically useful. Several MDA-based methodologies exist today, yet the need remains for the definition of an instantiable MDA-based development process. We propose a generic lifecycle for MDA-based software development that can be used as a basis for constructing MDA-based methodologies through a Method Engineering (ME) process. The phases and activities of the proposed lifecycle are described herein, with a number of prominent MDA-based methodologies assessed as to their degree of conformance to the proposed lifecycle.
7F3C2074	A description is given of Aquarius IIU, a complex system integrating a high-performance symbolic microprocessor, an instruction prefetcher, snooping data and instruction caches, a VME bus interface, and a set of controllers. Aquarius IIU is based on the high performance VLSI-PLM chip that runs the Warren abstract machine instruction set. Many of these nodes have been connected using a shared bus to form a multiprocessor which has its own shared memory and snooping caches and is used as a backend Prolog engine to the host (SUN3/160). On every node, there are two controllers per data and instruction cache that cooperate to support Berkeley's snooping cache-lock state protocol, which minimizes bus traffic associated with locking blocks. The nodes share memory using the signals of the VME bus; the page faults and memory management are handled by the host. A top-down method was used in the design of the Aquarius IIU node, while a bottom-up method was used in the simulations. In designing and simulating complex systems such as the Aquarius IIU, the procedure followed was found to be advantageous.
7E481A85	Multi-core programming is no more a luxury; it is now a necessity, because even embedded processors are becoming multi-core. However, the state-of-the-art techniques such as OpenMP and the Intel Threading Building Block (TBB) library are far from user-friendly due to the tedious work needed in explicitly designing multi-core programs and debugging. At the present days, a solution for above problems will be that to enhance the abstract level of multicore embedded software design. By leveraging on the expertise gained from Verifiable Embedded Real-Time Application Framework (VERTAF), we propose a Multi-Core version of VERTAF, called VERTAF/ Multi-core (VMC in short). VMC is an integrated development environment for multi-core embedded software architecture. Developers would be able to 1. describe their system requirements with SysML by using this environment, 2. model their design with SysML standard notation, 3. automatically apply a pattern structure into their design for a high quality multicore embedded system, 4. generate source code through a well-designed model; 5. map to different hardware architecture as assigned by the model, and 6. finally we can test the code.Using the model driven architecture (MDA) design flow in SysML, we saw a significantly improvement on productivity and quality of a multicore embedded programming over traditional approach.
7F3D2FB0	Continuous availability is a critical requirement for an important class of software systems. For these systems, runtime system evolution can mitigate the costs and risks associated with shutting down and restarting the system for an update. We present an architecture-based approach to runtime software evolution and highlight the role of software connectors in supporting runtime change. An initial implementation of a tool suite for supporting the runtime modification of software architectures, called ArchStudio, is presented. 
709EB156	Instructional systems development (ISD) has proved to be effective for developing software maintenance education courses. The process of ISD involves the establishment of specific performance objectives which are addressed through classroom instruction and laboratory experience. Students graduate when they are able to pass stringent tests against the established objectives. ISD incorporates the following five stages: analyze system requirements; define education or training requirements; develop objectives and tests; plan, develop, and validate instruction; and conduct and evaluate instruction. Progressing through these stages ensures that an effective course of instruction is in place. An example is presented of the application of ISD.
7E044973	The demand for flexible and scalable mechatronic system is becoming more and more attractive. Modular systems made from a large number of modules can be formed various physical or logical topologies, consequently to achieve the capabilities to optimize their configurations to suit different applications. Although, modular concept will bring new scalable and extendable products for customers, it puts new requirements for the product development. Shift from tightly-coupled systems to service-oriented architecture will bring deep impact to the research and development of the modular embedded devices, applications and services, i.e. function elements can be easily added or removed without modifying the whole hardware and software of the systems. In this paper, we first discuss the opportunities, challenges and requirements for the modular mechatronic systems development, and then, present directions for loose-coupled modular devices based on service-oriented control architecture, in particular, this paper outlines the implementation of this architecture adopted by the Miniaturized Modular Devices project.
78938265	Software architectures promote development focused on modular building blocks and their interconnections. Since architecture-level components often contain complex functionality, it is reasonable to expect that their interactions will also be complex. Modeling and implementing software connectors thus becomes a key aspect of architecture-based development. Software interconnection and middleware technologies such as RMI, CORBA, ILU, and ActiveX provide a valuable service in building applications from components. The relation of such services to software connectors in the context of software architectures, however, is not well understood. To understand the tradeoffs among these technologies with respect to architectures, we have evaluated several off-the-shelf middleware technologies and identified key techniques for utilizing them in implementing software connectors. Our platform for investigation was C2, a component- and message-based architectural style. By encapsulating middleware functionality within software connectors, we have coupled C2's existing benefits such as component interchangeability, substrate independence and structural guidance with new capabilities of multi-lingual, multi-process and distributed application development in a manner that is transparent to architects.
808E770D	One of the challenging problems for software developers is guaranteeing that a system as built is consistent with its architectural design. In this paper, we describe a technique that uses run time observations about an executing system to construct an architectural view of the system. With this technique, we develop mappings that exploit regularities in system implementation and architectural style. These mappings describe how low-level system events can be interpreted as more abstract architectural operations. We describe the current implementation of a tool that uses these mappings, and show that it can highlight inconsistencies between implementation and architecture.
5F7C941F	 The objective of this work was to explore algorithms and their implementation for future advanced parallel systems. These systems are assumed to have hundreds or even thousands of processors and to be able to concentrate their computing power on one or a small number of tasks. The three principal questions to be explored were: 1) Are there algorithms for the crucial applications which have enough parallelism to allow the power of the advanced parallel systems to be fully exploited?; 2) What languages and implementation tools are needed for efficient programming of these algorithms?; 3) What are the relative performances of different algorithm types? Of different architecture types? Of different implementation languages? The research results obtained appear in this report.
77E1901E	File sharing applications using Peer-to-Peer (P2P) networks such as Bittorrent or eDonkey rapidly attracted a lot of people and proved the efficiency and interest of this P2P technology. Distribution of video and of live contents also experienced the P2P mechanisms with success. PPLive, UUSee and others have many of customers, hundreds of channels and thousands of concurrent users. However, major content providers are reluctant to use this technology because no solution to ensure the distribution of only legal contents is provided. In the same way, network operators do not really push towards P2P content distribution because bad organization of the overlay can lead to overload the network and consume a lot of networks resources. In this paper, a secure and legal network-aware P2P video system is introduced, which aims at overcoming those two drawbacks. The design of the system and the evaluation of a prototype showed good results and let us be optimistic about a possible deployment of P2P systems for video delivery, having the support of content providers as well as network operators.
7EE734F3	There are six independent projects within the DSSA program. Four of these projects are working in specific, military-significant domains. Those domains are Avionics Navigation, Guidance and Flight Director for Helicopters; Command and Control; Distributed Intelligent Control and Management for Vehicle Management; Intelligent Guidance, Navigation and Control for Missiles. In addition, there are two projects working on underlying support technology. Hybrid (discrete and continuous, non-linear) Control and Prototyping Technology. 
7F9BE110	As the size of software systems increases, the algorithms and data structures of the computation no longer constitute the major design problems. When systems are constructed from many components, the organization of the overall system -- the software architecture -- presents a new set of design problems. This level of design has been addressed in a number of ways including informal diagrams and descriptive terms, module interconnection languages, templates and frameworks for systems that serve the needs of specific domains, and formal models of component integration mechanisms. In this paper we provide an introduction to the emerging field of software architecture. We begin by considering a number of common architectural styles upon which many systems are currently based and show how different styles can be combined in a single design. Then we present six case studies to illustrate how architectural representations can improve our understanding of complex software systems. Finally, we survey some of the outstanding problems in the field, and consider a few of the promising research directions.
7EFA2FA0	The available frameworks for adaptive systems propose various solutions for addressing and implementing software which is adaptable at runtime. These solutions have different perspective on adaptivity: architectural, structural, or behavioral. Hence, based on which criteria should be decided which framework to adopt? In this paper, we present a possible approach to evaluate the available frameworks through a set of metrics which aim to capture the main issues of adaptive systems from the development perspective.
7FEA9F6C	Architectures for software use rich abstractions and idioms to describe system components, the nature of interactions among the components, and the patterns that guide the composition of components into systems. These abstractions are higher level than the elements usually supported by programming languages and tools. They capture packaging and interaction issues as well as computational functionality. Well-established (if informal) patterns guide the architectural design of systems. We sketch a model for defining architectures and present an implementation of the basic level of that model. Our purpose is to support the abstractions used in practice by software designers. The implementation provides a testbed for experiments with a variety of system construction mechanisms. It distinguishes among different types of components and different ways these components can interact. It supports abstract interactions such as data flow and scheduling on the same footing as simple procedure call. It can express and check appropriate compatibility restrictions and configuration constraints. It accepts existing code as components, incurring no runtime overhead after initialization. It allows easy incorporation of specifications and associated analysis tools developed elsewhere. The implementation provides a base for extending the notation and validating the model.
733C702D	The continually increasing integration density of integrated circuits portrays important paradigm shifts in next-generation designs, especially in the direction of systems-on-a-chip. Hybrid architectures mixing a variety of computational models are bound to be integrated on a single die. This opens the door for creative high-performance low-energy solutions to the programming problem using techniques such as reconfiguration to construct optimized architectures for a given computational problem. Exploiting the opportunities offered by these architectural innovations obviously requires a clear understanding of the trade-off's offered by the various architectural models and styles, as well as a well-thought out design methodology, combining high-level prediction and analysis tools with partitioning, optimization and mapping techniques. This paper presents an overview of opportunities of these reconfigurable architectures in the architecture domain.
7D0A1DDD	 The integration of new or existing software components into established architectures and the ability to deal with heterogeneity are key requirements for middleware and development frameworks for robotic systems. This paper presents SPICA, a software development framework for communication infrastructures of autonomous mobile robots. Utilizing the model-driven software development paradigm, communication and data flow can be defined on an abstract level. For this purpose, domain-specific languages and tools are provided that allow specification and generation of module communication infrastructures for communication between modules along with primitives for data management. The high-level platform-independent specifications are automatically transformed into low-level platform and programming language-specific source code. We illustrate the applicability of our approach with an elaborate example describing the design of a soccer robot architecture that has proven its strength during RoboCup 2006. Our experiences have revealed that SPICA is advantageous for prototyping as well as for building high performance systems
63DB3066	The theory of reactive systems, introduced by Leifer and Milner and previously extended by the authors, allows the derivation of well-behaved labelled transition systems (LTS) for semantic models with an underlying reduction semantics. The derivation procedure requires the presence of certain colimits (or, more usually and generally, bicolimits) which need to be constructed separately within each model. In this paper, we offer a general construction of such bicolimits in a class of bicategones of cospans. The construction sheds light on as well as extends Ehrig and Konig's rewriting via borrowed contexts and opens the way to a unified treatment of several applications.
05E53073	This report describes a procedure for designing computer systems that are developed specifically to be a component of a more complex system. Two significant characteristics of such design problems are the following: the computer system interface is determined by factors outside the control of the computer system designer, and the specifications of that interface are likely to change throughout the life cycle of the system. The purpose of the procedure described in this report is to reduce maintenance costs by means of a software organization that insulates most of the programs from changes in the interface. The procedure is based on the systematic compilation of an assumption list. The assumption list describes those aspects of the interface that future users and other knowledgeable persons consider essential and therefore stable. Other aspects of the interface are ignored. An abstract interface is designed on the basis of this assumption list. A specification of the abstract interface is used to procure the major components of the system. This report explains the principles behind the procedure and illustrates its use. The success of the procedure is primarily limited by the ability of designers and future users to compile an accurate list of assumptions. A side benefit of the procedure is simpler, better structured software. Successful application of the procedure should result in both increased reliability and reduced lift-cycle costs. (Author)
80E31996	Software architectures shift the focus of developers from lines-of-code to coarser-grained architectural elements and their overall interconnection structure. Architecture description languages (ADLs) have been proposed as modeling notations to support architecture-based development. There is, however, little consensus in the research community on what is an ADL, what aspects of an architecture should be modeled in an ADL, and which of several possible ADLs is best suited for a particular problem. Furthermore, the distinction is rarely made between ADLs on one hand and formal specification, module interconnection, simulation, and programming languages on the other. This paper attempts to provide an answer to these questions. It motivates and presents a definition and a classification framework for ADLs. The utility of the definition is demonstrated by using it to differentiate ADLs from other modeling notations. The framework is used to classify and compare several existing ADLs, enabling us, in the process, to identify key properties of ADLs. The comparison highlights areas where existing ADLs provide extensive support and those in which they are deficient, suggesting a research agenda for the future.
8083377D	With the shrinking defense budget, the U. S. Department of Defense (DoD) has relied more on commercial-off-the-shelf (COTS) and contracted software systems. Government contractors and commercial developers currently rely heavily on semi-formal methods such as the Unified Modeling Language (UML) in developing the models and requirements for these software systems. The correctness of specifications in such languages cannot be tested, in general, until they are implemented. Due to the inherent safety requirements for mission critical systems, formal specification methods would be preferable. This thesis contrasts the development of a combat system for the Navy using the formal specification language SPEC with development using the semi-formal method UML. The application being developed is a ship recognition system that utilized image data, detected emitters, and ship positioning to correlate ship identification. The requirements analysis and architectural design for this system are presented.
65AB8165	System integration refers to combining some or all of the functionality of two or more software and/or database systems. This differs from systems interfacing which refers to linking the functionality of two or more systems via another system component specifically designed for that purpose. Systems integration implies making two or more systems work as one system and not necessarily to make multiple systems work in tandem. This paper advocates the advantages of using CASE tool development software for systems integration activities. It also addresses other beneficial software project management data which is created as a result.
80F48122	Most traditional systems produce a fixed quality of output under a fixed execution environment given identical input, even when the user does not need that quality of solution. We propose a new software architecture that can do quality-driven operations. The key concept of the architecture is that it contains multiple configurations so that it can adapt itself to fit various user requirements and constraints. The adaptation involves the tradeoff of a set of quality of service factors in order to provide the best feasible performance. A simple application is presented to demonstrate the power of the architecture. This quality-driving concept can be introduced to many domains; in fact, any resource-constrained or pay-per-use applications can be improved by the concept to provide a range of quality of services.
7F42F2D5	Experience from a dozen years of analyzing software engineering processes and products is summarized as a set of software engineering and measurement principles that argue for software engineering process models that integrate sound planning and analysis into the construction process. In the TAME (Tailoring A Measurement Environment) project at the University of Maryland, such an improvement-oriented software engineering process model was developed that uses the goal/question/metric paradigm to integrate the constructive and analytic aspects of software development. The model provides a mechanism for formalizing the characterization and planning tasks, controlling and improving projects based on quantitative analysis, learning in a deeper and more systematic way about the software process and product, and feeding the appropriate experience back into the current and future projects. The TAME system is an instantiation of the TAME software engineering process model as an ISEE (integrated software engineering environment). The first in a series of TAME system prototypes has been developed. An assessment of experience with this first limited prototype is presented including a reassessment of its initial architecture.
7D2E7D95	Gaining an architectural level understanding of a software system is important for many reasons. When the description of a system's architecture does not exist, attempts must be made to recover it. In recent years, researchers have explored the use of clustering for recovering a software system's architecture, given only its source code. The main contributions of this paper are given as follows. First, we review hierarchical clustering research in the context of software architecture recovery and modularization. Second, to employ clustering meaningfully, it is necessary to understand the peculiarities of the software domain, as well as the behavior of clustering measures and algorithms in this domain. To this end, we provide a detailed analysis of the behavior of various similarity and distance measures that may be employed for software clustering. Third, we analyze the clustering process of various well-known clustering algorithms by using multiple criteria, and we show how arbitrary decisions taken by these algorithms during clustering affect the quality of their results. Finally, we present an analysis of two recently proposed clustering algorithms, revealing close similarities in their apparently different clustering approaches. Experiments on four legacy software systems provide insight into the behavior of well-known clustering algorithms and their characteristics in the software domain.
6D6C6B05	Telepathology systems involving robotic controls are often very expensive and hard to justify by telepathology providers. In this paper, a telepathology system is discussed which costs less than $25,000 while supplying excellent diagnostic-functionality and network connectivity. The architecture proposed allows for dynamic interaction between pathologists that scales to the network bandwidth. Three important factors influence diagnostic accuracy in a telepathology system. First, preliminary data supports that dynamic systems perform better than static ones mainly because of better physician interaction and the ability to visualize the proper subset of diagnostic clues. Second, a frame rate below 8 frames/sec will not convey sufficient information for real-time interaction. Last, synchronization of the video between the 2 sites ensures that proper fields are transmitted. When considering telepathology systems, one must weigh the benefits, and the costs involved in the implementation. This design represents the compromise between robotic control and static systems.
80CABE78	Automotive systems engineering has made significant progress in using formal methods to design safe hardware-software systems. The architectures and design methods could become a model for safe and cost-efficient embedded software development as a whole. This paper gives several examples from the leading edge of industrial automotive applications.
738D7C85	Phase change memory (PCM) is considered as a promising alternative of DRAM-based main memory in embedded systems. A PCM cell can be dynamically programmed to be in either multiple-level cell (MLC) mode or single-level cell (SLC) mode. With this morphable feature, we can utilize the high-density of MLC and low-latency of SLC, to satisfy various memory requirements of specific applications in embedded systems. However, compared to its SLC counterpart, the lifetime of MLC is limited. In particular, a program in embedded systems usually exhibits an extremely unbalanced write pattern, which may accelerate the wear-out of MLC cells in morphable PCM. To address this issue, this paper proposes a simple and effective wear-leveling technique, named Mixer, to enhance the lifetime of morphable PCM considering the program specific features. We first build an Integer Linear Programming (ILP) formulation to produce optimal SLC/MLC partition and data allocation, to achieve a balanced write distribution in morphable PCM with low memory access cost. The basic idea is to allocate fast SLC and MLC cells for write intensive variables and other ordinary variables, respectively. We then propose a polynomial time algorithm to achieve near-optimal results. The evaluation results show that the proposed technique can effectively extend the lifetime of morphable PCM in embedded systems compared with previous work.
80F89D7B	We sketch work-in-progress in the area of systems architecting, which we regard as a fundamental element of system-level requirements engineering. We present our ideas on systems architecting, and relate them to the field of Architecture proper (as in buildings). We present our notion of system-wide scenarios and how these can be derived from contextual analysis of information systems, using a well-established qualitative data analysis methodology from the social sciences.
7E608632	The authors summarize the goals of metric-driven analysis and feedback systems and describe a prototype system, Amadeus, which defines abstract interfaces and embodies architectural principles for these types of systems. Metric-driven analysis and feedback systems enable developers to define empirically guided processes for software development and maintenance. The authors provide an overview of the Amadeus system operation, including an example of the empirically guided process, a description of the system characteristics, an explanation of the system conceptual operation, and a summary of the users' view of the system. The centerpiece of the system is a pro-active server, which interprets scripts and coordinates event monitoring and agent activation. Amadeus provides an extensible framework for adding new empirically based analysis techniques.
7DDAED8F	In this paper, we present field-programmable gate-array (FPGA)-based configurable architectures that are able to perform frequency-diverse target detection for real-time ultrasonic imaging. Three design methodologies are explored including the execution of the detection algorithm on an embedded microprocessor, the creation of a dedicated hardware solution, and the use of hardware/software codesign principles. In addition to the design flow, this paper presents the impact of parameter changes on the detection-algorithm performance and FPGA implementation results. Experimental studies show that the proposed configurable systems are able to meet real-time operation requirements, and the algorithm performs robustly.
75F930F7	Undocumented evolution of a software system and its underlying architecture drives the need for the architectures recovery from the systems implementation-level artifacts. While a number of recovery techniques have been proposed, they suffer from known inaccuracies. Furthermore, these techniques are difficult to evaluate due to a lack of ground-truth architectures that are known to be accurate. To address this problem, we argue for establishing a suite of ground-truth architectures, using a recovery framework proposed in our recent work. This framework considers domain-, application-, and contextspecific information about a system, and addresses an inherent obstacle in establishing a ground-truth architecture the limited availability of engineers who are closely familiar with the system in question. In this paper, we present our experience in recovering the ground-truth architectures of four open-source systems. We discuss the primary insights gained in the process, analyze the characteristics of the obtained ground-truth architectures, and reflect on the involvement of the systems engineers in a limited but critical fashion. Our findings suggest the practical feasibility of obtaining ground-truth architectures for large systems and encourage future efforts directed at establishing a large scale repository of such architectures. 
7D17A232	There are many economic and technical arguments for the reduction of the number of Electronic Control Units (EC Us) aboard a car. One of the key obstacles to achieve this goal is the limited composability, fault isolation and error containment of today's single- processor architectures. However, significant changes in the chip architecture are taking place in order to manage the synchronization, energy dissipation, and fault-handling requirements of emerging billion transistor SoCs (systems-on-a-chip). The single processor architecture is replaced by multi-core SoCs that communicate via networks-on-chip (NoC). These emerging multi-core SoCs provide an ideal execution environment for the integration of multiple automotive ECUs into a single SoC This paper presents a model-based software development method for designing applications using these multi-core SoCs.
5E219F49	The Analytic System and Software for Evaluating Safeguards and Security (ASSESS) has been released for use by DOE field offices and their contractors. In October, 1989, we offered a prototype workshop to selected representatives of the DOE community. Based on the prototype results, we held the first training workshop at the Central Training Academy in January, 1990. Four additional workshops are scheduled for FY 1990. ASSESS is a state-of-the-art analytical tool for management to conduct integrated evaluation of safeguards systems at facilities handling facilities. Currently, ASSESS focuses on the threat of theft/diversion of special nuclear material by insiders, outsiders, and a special form of insider/outsider collusion. ASSESS also includes a neutralization module. Development of the tool is continuing. Plans are underway to expand the capabilities of ASSESS to evaluate against violent insiders, to validate the databases, to expand the neutralization module, and to assist in demonstrating compliance with DOE Material Control and Accountability (MC A) Order 5633.3. These new capabilities include the ability to: compute a weighted average for performance capability against a spectrum of insider adversaries; conduct defense-in-depth analyses; and analyze against protracted theft scenarios. As they become available, these capabilities will be incorporated in our training program. ASSESS is being developed jointly by Lawrence Livermore and Sandia National Laboratories under the sponsorship of the Department of Energy (DOE) Office of Safeguards and Security.
8070DACF	Future space missions call for advanced computing system architectures fulfilling strict size, weight and power consumption (SWaP) requisites, decreasing the mission cost and ensuring the safety and timeliness of the system. The AIR (ARINC 653 in Space Real-Time Operating System) architecture defines a partitioned environment for the development and execution of aerospace applications, following the notion of time and space partitioning (TSP), preserving application timing and safety requisites. Due to the change of the mission plans or in the presence of unexpected events, it may be necessary or useful to be able to reconfigure the scheduling of the system applications at execution time. In this paper we present an algorithm for updating application schedules, showing results from the proof-of-concept prototype in the scope of the AIR architecture.