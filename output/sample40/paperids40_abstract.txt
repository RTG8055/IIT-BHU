7F5B0762	Supporting uninterrupted services for distributed soft real-time applications is hard in resource-constrained and dynamic environments, where processor or process failures and system workload changes are common. Fault-tolerant middleware for these applications must achieve high service availability and satisfactory response times for client applications. Although passive replication is a promising fault tolerance strategy for resource-constrained systems, conventional client failover approaches are non-adaptive and load-agnostic, which can cause system overloads and significantly increase response times after failure recovery.This paper presents four contributions to the study of passive replication for distributed soft real-time applications. First, it describes how our Fault-tolerant Load-aware and Adaptive middlewaRe (FLARe) dynamically adjusts failover targets at runtime in response to system load fluctuations and resource availability. Second, it describes how FLARe's overload management strategy proactively enforces desired CPU utilization bounds by redirecting clients from overloaded processors. Third, it presents the design and implementation of FLARe's lightweight middleware architecture that manages failures and overloads transparently to clients. Finally, it presents experimental results on a distributed Linux testbed that demonstrate how FLARe adaptively maintains soft real-time performance for clients operating in the presence of failures and overloads with negligible runtime overhead.
7FAB19D6	Real-time transient simulation of large transmission networks requires significant computational power. This paper proposes a field-programmable gate array (FPGA)-based real-time electromagnetic transient simulator. Taking advantage of the inherent parallel architecture, high density, and high clock speed, the real-time Electromagnetic Transients Program (EMTP) is implemented on a single FPGA chip. It is based on a paralleled algorithm that is deeply pipelined, and uses a floating-point arithmetic calculation to achieve high accuracy for simulating fast electromagnetic transients. To validate the new simulator, a sample system with 15 transmission lines using full frequency-dependent modeling is simulated in real time. A timestep of 12 mus has been achieved based on a 12.5-ns clock period with high data throughput. The captured real-time oscilloscope results demonstrate excellent accuracy of the simulator in comparison to the offline simulation of the original system in the Alternative Transients Program version of EMTP.
7F909201	This paper provides two contributions to the study of quality of service (QoS)-enabled middleware that supports the network QoS requirements of distributed real-time and embedded (DRE) systems. First, we describe the design and implementation of NetQoPE, which is a model-driven component middleware framework that shields applications from the details of network QoS mechanisms by (1) specifying per-flow network QoS requirements, (2) performing resource allocation and validation decisions (such as admission control), and (3) enforcing per-flow network QoS at runtime. Second, we evaluate the effort required and flexibility of using NetQoPE to provide network QoS assurance to end-to-end application flows. Our results demonstrate that NetQoPE can provide network-level differentiated performance to each application flow without modifying its programming model or source code, thereby providing greater flexibility in leveraging network-layer mechanisms.
7E1A7A39	The emergence of functional embedded systems such as cell-phones and digital appliances brought up a new issue, building a system supporting both real-time and rich services. One of the solutions is leveraging a hypervisor to integrate an RTOS and a commodity OS into a single device. However, this approach induces the limitation of application deployment; all the high priority tasks should reside in the RTOS.In this paper, we propose a task grain scheduling for a real-time hypervisor, which enables a flexible application deployment between an RTOS and a commodity OS.  We constructed a prototype system with an existing hypervisor, an RTOS, and a commodity OS. We measured some basic overheads, and fixed some tasks which were missing their deadlines using the task grain scheduling to meet their deadlines. The overheads were small and the task grain scheduling achieved a flexible real-time scheduling for the hypervisor based system.
5E138E90	A recent trend has seen the extension of object-oriented middleware. A major advantage components offer over objects is that only the business logic of an application needs to be addressed by a programmer with support services required incorporated into the application at deployment time. This is achieved via components (business logic of an application), containers that host components and are responsible for providing the underlying middleware services required by components and application servers that host containers. Well-known examples of component middleware architectures are Enterprise Java Beans (EJBs) and the CORBA Component model (CCM). Two of the many services available at deployment time in most component architectures are component persistence and atomic transactions. This paper examines, using EJBs, how replication for availability can be supported by containers so that components that are transparently using persistence and transactions can also be made highly available.
74972C61	There is a growing need to provide students with meaningful system-level design (SLD) experiences at the undergraduate level. Relevant SLD skills include the ability to integrate IP from third-party providers, create reusable IP (including appropriate documentation), partition system functionality between software and hardware, and properly integrate real-time functions within an operating system. A senior SLD project was created to provide such an experience for undergraduate students. With cooperation from Xilinx corporation, this single semester course provides students the opportunity to learn SLD skills by creating a single-chip multimedia computer system using FPGAs. Students in this class integrate custom IP and third-party IP into a PowerPC-based system within a single FPGA device. The final product is a real-time multimedia computer system providing both audio and video services. This paper describes the SLD course, beginning by outlining its goals and requirements. Next, the hardware and software infrastructure used by the project is described. Finally, the class schedule is reviewed.
808824F7	In reality, peripheral devices often make a significant contribution to the power consumption of the entire system. An effective energy-efficient scheduling algorithm should consider not only the energy consumption of the processor but also the usages of devices. In this paper, we explore energy-efficient scheduling of periodic real-time tasks in a system with a dynamic-voltage-scaling (DVS) processor and multiple non-DVS system devices. We consider systems that any device used by a task remains operating while the task is active. We propose scheduling algorithms in the management of task preemption to reduce the energy consumption of devices. Simulation results show that our proposed algorithms could not only reduce the number of task preemption significantly but also minimize the energy consumption, compared to earliest-deadline-first scheduling.
7C2230AD	The paper presents a distributed real-time operating system (DRTOS) for hard real-time embedded systems such as automotive control systems. A real-time control application program is usually designed as a set of tasks that cooperate with each other through the mechanism of a real- time operating system. In a distributed embedded control system, location-transparent mechanisms are required because the tasks are allocated to multiple nodes. We have developed a DRTOS that provides location-transparent system calls for task management and inter-task synchronization. The DRTOS is an extension to OSEK OS, which is a standard operating system in the automotive control domain. The DRTOS manages distributed tasks based on the global time supported by the clock synchronization of FlexRay, which is a real-time network based on a TDMA (Time Division Multiple Access) protocol. By using the DRTOS, we can develop a distributed control application program with location-transparent system calls. We can also reallocate the tasks of the application program just by reconfiguration, without rewriting the source code. The worst case response time of a remote system call of the DRTOS is predictable if the FlexRay communication is well configured.
7CC7B191	Timing predictability of service oriented architectures is challenged by their dynamic nature. Systems have to reconfigure their service-based structure to adapt to the changing environmental requirements. The development of dynamic systems that have timing constraints is currently not possible without imposing some bounds and limitations to the structure and operation of the system. This paper identifies the key factors for achieving time-bounded service-based reconfiguration from a system perspective. The key contribution to bypass the possible complexity of the used task model and associated schedulability analysis algorithm is the provided architectural design that separates the composition from the schedulability. The paper also extends a previous service composition algorithm that provided a feasible solution compliant with the application quality of service criteria (QoS). Due to the design based on the separation of concerns, the algorithm is a simple straight forward graph search guided by values related to the application QoS. The generalized algorithm offers a search mechanism guided through n regions going beyond the four regions model of the previous contribution. Results from the previous algorithm and the n regions version are shown to illustrate the advantages and finer grain results of the latter.
802D8BC3	End-to-end predictability of remote operations is essential for many fixed-priority distributed real-time and embedded (DRE) applications, such as command and control systems, manufacturing process control systems, large-scale distributed interactive simulations, and testbeam data acquisition systems. To enhance predictability, the Real-time CORBA specification defines standard middleware features that allow applications to allocate, schedule, and control key CPU, memory, and networking resources necessary to ensure end-to-end quality of service support. This paper provides two contributions to the study of Real-time CORBA middleware for DRE applications. First, we identify potential problems with ensuring predictable behavior in conventional middleware by examining the end-to-end critical code path of a remote invocation and identifying sources of unbounded priority inversions. Experimental results then illustrate how the problems we identify can yield unpredictable behavior in conventional middleware platforms. Second, we present design techniques for ensuring real-time quality of service in middleware. We show how middleware can be redesigned to use nonmultiplexed resources to eliminate sources of unbounded priority inversion. The empirical results in this paper are conducted using TAO, which is widely used and open-source DRE middleware compliant with the Real-time CORBA specification
758811F9	Many application domains (e.g., avionics, telecommunications, and multimedia) require real-time guarantees from the underlying networks, operating systems, and middleware components to achieve their quality of service (QoS) requirements. In addition to providing end-to-end QoS guarantees, applications in these domains must be flexible and reusable. Requirements for flexibility and reusability motivate the use of object-oriented middleware like the Common Object Request Broker Architecture (CORBA). However, the performance of current CORBA implementations is not yet suited for hard real-time systems (e.g., avionics) and constrained latency systems (e.g., teleconferencing). This article describes the architectural features and optimizations required to develop real-time ORB end systems that can deliver end-to-end QoS guarantees to applications. While some operating systems, networks, and protocols now support real-time scheduling, they do not provide integrated solutions. The main thrust of this article is that advances in real-time distributed object computing can be achieved only by systematically pinpointing performance bottlenecks; optimizing the performance of networks, ORB end systems, common services, and applications; and simultaneously integrating techniques and tools that simplify application development.
71095C34	There is increasing demand to extend Object Request Broker (ORB) middleware to support distributed applications with stringent real-time requirements. However, conventional ORE implementations, such as CORBA ORBs, exhibit substantial priority inversion and non-determinism, which makes them unsuitable for applications with deterministic real-time requirements. The paper provides two contributions to the study and design of real-time ORB middleware. First, it illustrates empirically why conventional ORBs do not yet support real-time quality of service. Second, it evaluates connection and concurrency software architectures to identify strategies that reduce priority inversion and non-determinism in real-time CORBA ORBs.
7E5A6EBA	The workshop is a small, high quality and interactive meeting for novel P2P ideas and proposals. On the one hand, collaborative P2P systems aim to benefit from the huge amount of unused resources of desktop computers (content, data storage, cpu, bandwidth) to create the next generation of Internet Infrastructures. On the other hand, P2P is particularly challenging for developing collaborative information systems. In this line, P2P can be used to create social networks and communities, to discover users and information, to aggregate community contents or even as a communication medium for large groups. The Fifth International Workshop on Collaborative Peer-to-Peer Systems has attracted high quality submissions from top research groups around the world. It received 27 submissions from 14 countries and it is creating a vibrant community of researchers in the peer-to-peer topic. After the review process, 10 full papers, and 1 short paper were included in the final program. The high quality submissions have demonstrated the relevance of the topic and the recent trends in the peer-to-peer research community. The workshop was divided in three sessions: algorithms, middleware and security. Every paper addresses a hot topic in peer-to-peer research and relevant researchers in the area presented their recent contributions.
7E755772	An agent-oriented middleware supporting contextaware and adaptable mLearning service provision within an InfoStation-based University network is presented. The InfoStation's middleware architecture facilitating the users' mobile (WiFi) access to services is described. The agents' interaction is explained in detail.
80C907A1	The distributed embedded systems industry is poised to leverage emerging real-time operating systems, such as Inferno Windows CE, EPOC, and Palm OS to support mobile communication applications, such as electronic mail, Internet browsing, and network management. Ideally, these applications can be developed using standard middleware components like CORBA to improve their quality and reduce their cost and cycle time. However, stringent constraints on memory available in embedded systems imposes a severe limit on the footprint of CORBA middleware. This paper provides three contributions to the study and design of small footprint, embedded CORBA middleware. First, we describe the optimizations used to develop the protocol engine and CORBA IDL compiler provided by TAO, which is our real-time CORBA implementation. TAO's IDL compiler produces stubs that can use either compiled and/or interpretive marshalling. Second, we compare the performance and footprint of TAO IDL compiler-generated stubs and skeletons that use compiled and/or interpretive marshalling for a wide range of IDL data types. Third, we illustrate the benefits of the small footprint and efficiency of TAO IDL compiler-generated stubs and skeletons for CORBA object services implemented using TAO. The results comparing the performance of the compiled and interpretive stubs and skeletons indicate that the interpretive stubs and skeletons perform between 75-100% of the compiled stubs and skeletons for a wide range of data types. However the code size for the interpreted stubs and skeletons was between 26-45% and 50-80% of the compiled stubs and skeletons, respectively. These results indicate a positive step towards implementing high performance, small footprint middleware for distributed embedded systems.
78A7BE36	In this work we present a middleware architecture for a mobile peer-to-peer content distribution system. Our architecture allows wireless content dissemination between mobile nodes without relying on infrastructure support. Contents are exchanged opportunistically when nodes are within communication range. Applications access the service of our platform through a publish/subscribe interface and therefore do not have to deal with low-level opportunistic networking issues or matching and soliciting of contents. Our architecture consists of three key components. A content structure that facilitates dividing contents into logical topics and allows for efficient matching of content lookups and downloading under sporadic node connectivity. A solicitation protocol that allows nodes to solicit content meta-information in order to discover contents available at a neighboring node and to download content entries disjointedly from different nodes. An API that allows applications to access the system services through a publish/subscribe interface. In this work we describe the design and implementation of our architecture. We also discuss potential applications and present evaluation results from profiling of our system.
7DFDBAF5	To be an effective platform for performance-sensitive real time systems, commercial-off-the-shelf (COTS) distributed object computing (DOC) middleware must support application quality of service (QoS) requirements end-to-end. However, conventional DOC middleware does not provide this support, which makes it unsuited for applications with stringent latency, determinism, and priority preservation requirements. It is essential, therefore, to develop standards based, COTS DOC middleware that permits the specification, allocation, and enforcement of application QoS requirements end-to-end. The Real-time CORBA and Messaging specifications in the forthcoming CORBA 3.0 standard are important steps towards defining standards based COTS DOC middleware that can deliver end-to-end QoS support at multiple levels in distributed and embedded real time systems. However these specifications still lack sufficient detail to portably configure and control processor, communication, and memory resources for applications with stringent QoS requirements. The paper provides four contributions to research on real time DOC middleware. First, we show how the CORBA 3.0 Real-time and Messaging specifications provide a starting point for addressing the needs of an important class of applications with stringent real time requirements. Second, we show how the CORBA 3.0 specifications are not sufficient to solve all the issues within this application domain. Third, we describe how we have implemented portions of these specifications, as well as several enhancements, using TAO, which is our open-source real time CORBA ORB. Finally, we empirically evaluate the performance of TAO to illustrate how its features address the QoS requirements of certain types of real time applications.
7EC7FF26	Many real-time application domains can benefit from flexible and open distributed architectures, such as those defined by the CORBA specification. CORBA is an architecture for distributed object computing being standardized by the OMG. Although CORBA is well-suited for conventional request/response applications, CORBA implementations are not yet suited for real-time applications due to the lack of key quality of service (QoS) features and performance optimizations. This paper makes three contributions to the design of real-time CORBA systems. First, the paper describes the design of TAO, which is our high-performance, real-time CORBA 2.0-compliant implementation that runs on a range of OS platforms with real-time features including VxWorks, Chorus, Solaris 2.x, and Windows NT. Second, it presents TAO's real-time scheduling service that can provide QoS guarantees for deterministic real-time CORBA applications. Finally, the paper presents performance measurements that demonstrate the effects of priority inversion and non-determinism in conventional CORBA implementations and how these hazards are avoided in TAO.
7DDF8C83	Large scale distributed real time and embedded (DRE) applications are complex entities that are often composed of different subsystems and have stringent Quality of Service (QoS) requirements. These subsystems are often developed separately by different developers increasingly using commercial off-the shelf (COTS) middleware. Subsequently, these subsystems need to be integrated, configured to communicate with each other, and distributed. However, there is currently no standard way of supporting these requirements in existing COTS middleware. While recently emerging component-based middleware provides standardized support for packaging, assembling, and deploying, there is no standard way to provision QoS required by the DRE applications. We have previously introduced a QoS encapsulation model, qoskets, as part of our QuO middleware framework that can dynamically adapt to resource constraints. In this paper we introduce implementing these QoS behaviors as components that can be assembled with other application components. The task of ensuring QoS then becomes an assembly issue. To do so we have componentized our QuO technology instead of integrating QuO into the middleware as a service. To date, we have demonstrated our approach of QoS provisioning in MICO, CIAO, and Boeing’s Prism component middleware. We present experimental results to evaluate the overhead incurred by these QoS provisioning components in the context of CIAO CCM. We use a simulated Unmanned Aerial Vehicle (UAV) application as an illustrative DRE application for the demonstration of QoS adaptations using qosket components.
7F8E640F	To support the quality-of-service (QoS) requirements of embedded multimedia applications off-the-shelf middleware like common object request broker architecture (CORBA) must be flexible, efficient, and predictable. Moreover, stringent memory constraints imposed by embedded system hardware necessitates a minimal footprint for middleware that supports multimedia applications. This paper provides three contributions toward developing efficient object request broker's (ORBs) middleware to support embedded multimedia applications. First, we describe optimization principle patterns used to develop a time and space-efficient CORBA inter-ORB protocol (IIOP) interpreter for the adaptive communication environment (ACE)-ORB (TAO), which is our high-performance, real-time ORB. Second, we describe the optimizations applied to TAO's interface definition language (IDL) compiler to generate efficient and small stubs/skeletons used in TAO's IIOP protocol engine. Third, we empirically compare the performance and memory footprint of interpretive (de)marshaling versus compiled (de)marshaling for a wide range of IDL data types. Applying our optimization principle patterns to TAO's IIOP protocol engine improved its interpretive (de)marshaling performance to the point where it is now comparable to the performance of compiled (de)marshaling. Moreover, our IDL compiler optimizations generate interpreted stubs/skeletons whose footprint is substantially smaller than compiled stubs/skeletons. Our results illustrate that careful application of optimization principle patterns can yield both time and space-efficient standards-based middleware.
79A6D961	MERT is a multi-environment real-time operating system for the Digital Equipment PDP-11/45 and 11/70 computers. It is a structured operating system built on top of a kernel which provides the basic services such as memory management, process scheduling, and trap handling needed to build various operating system environments. Real-time response to processes is achieved by means of preemptive priority scheduling. The file system structure is optimized for real-time response. Processes are built as modular entities with data structures that are independent of all other processes. Interprocess communication is achieved by means of messages, event flags, shared segments, and shared files. Process ports are used for communication between unrelated processes.
785BB087	Software-based reconfiguration of distributed real-time systems is a complex problem with many sides to it ranging from system-wide concerns down to the intrinsic non-robust nature of the specific middleware layer and the used programming techniques. In a completely open distributed system, mixing reconfiguration and real-time is not possible; the set of possible target states can be very large threatening the temporal predictability of the reconfiguration process. Over the last years, middle ware solutions have appeared mainly for general purpose systems where efficient state transitions are sought for, but real-time properties are not considered. One of the few contributions to run-time software reconfiguration in distributed real-time environments has been the iLAND middleware, where the germ of a solution with high potential has been conceived and delivered in practice.1 The key idea has been the fact that a set of bounds and limitations to the structure of systems and to their open nature needs to be imposed in order to come up with practical solutions. In this paper, the authors present the different sides of the problem of software reconfiguration from two complementary middleware perspectives comparing two strategies built inside distribution middleware. We highlight the lessons learned in the iLAND project aimed at service-based reconfiguration and compare it to our experience in the development of distributed real-time Java reconfiguration based on distributed tasks rescheduling. Authors also provide a language view of both solutions. Lastly, empirical results are shown that validate these solutions and compare them on the basis of different programming language realizations.
8115183F	The design phase of any real-time system requires balancing the limited computational resources against the functional requirements and the performance of the application. The optimal design solution can be obtained by solving an optimization problem where the system performance is maximized within the schedulability constraints. In this paper, we provide a procedure that finds the task activation rates maximizing a performance function within the deadline constraints in systems scheduled by fixed priorities. First, we describe the exact feasibility region in the domain of task frequencies. Then, we introduce a procedure that starts by finding an initial solution, and incrementally improves it by using an original branch and bound search, until the global optimum is reached. Experiments show that our algorithm finds the optimal task periods for practical problems with a remarkable speedup, if compared with existing techniques. When the size of the problem makes the global search intractable, the experiments show that the algorithm can still find a high quality solution in the very early steps
7865D947	The steady increase in raw computing power of the processors commonly adopted for distributed real-time systems leads to the opportunity of hosting diverse classes of tasks on the same hardware, for example process control tasks, network protocol stacks and man–machine interfaces.This paper describes how virtualization techniques can be used to concurrently run multiple operating systems on the same physical machine, although they are kept fully separated from the security and execution timing points of view, and still have them exhibit acceptable real-time execution characteristics.With respect to competing approaches, the main advantages of this method are that it requires little or no modifications to the operating systems it hosts, along with a better modularity and clarity of design.
5F02D60B	Workflow manager is a useful tool that brings the power of computational Grid resources to the desktop, and allow them to conveniently put together and run their own scientific workflows. In existing workflow systems, individual tasks wait for input to be available perform computation,and produce output. Behind this, workflow manager automates the data movement from the data generating taskto the data consumption task. This process is referred as file staging. Generally, stage-in, process, and stage-out are serially executed and staging is treated by traditional workflow systems as a trivial step. However, as the data sizeis exponentially increasing and more and more scientific workflows require multiple processing steps to obtain the desired output, we argue that the data movement will possess high portion of overall running time and staging will become a challenging step of scientific workflow systems. In this paper, we propose a task pipelining framework for various e-Science workflow systems. Our system is a flexible and efficient tool to help the workflow systems to overlap the execution of adjacent tasks by enabling the pipelining ofthe intermediate data transfer between the interconnected tasks.
5E4297C6	Although component middleware is increasingly used to develop distributed, real-time and embedded (DRE) systems, it poses new fault-tolerance challenges, such as the need for efficient synchronization of internal component state, failure correlation across groups of components, and configuration of fault-tolerance properties at the component granularity level. This paper makes three contributions to R&D on component-based fault-tolerance. First, it describes the COmponent Replication based on Failover Units (CORFU) component middleware, which provides fail-stop behavior and fault correlation across groups of components treated as an atomic unit in DRE systems. Second, it describes how CORFU’s Components with HEterogeneous State Synchronization (CHESS) module provides mechanisms for real-time aware state transfer and synchronization in CORFU. Third, we empirically evaluate the client failover and group shutdown capabilities of CORFU and its CHESS module and compare/contrast it with existing object-oriented fault-tolerance methods. Our results show that component middleware (1) has acceptable fault-tolerance performance for DRE systems, (2) allows timely recovery while considering failure location, size, and functional topology of the group, and finally (3) eases the burden of application development by providing middleware support for fault-tolerance at the component level.
7ED97825	A new task mode, hardware logic task mode, is presented. Its architecture, schedule and implementation are described with HDL(Hardware Description Language), and the validity of the system has been proved by logic simulation. It has advantage for real-time applications and overheadsaving for operating system, so it is profitable for the controller in the embedded system. The relationship among RTOS (Real-Time Operating System), SoC (System on Chip), VIA (Virtual Interface Architecture) and hardware logic task is also discussed in the paper.
7E2BD844	Real-time operating systems generally depend on some form of priority information for making scheduling decisions. Priorities may take the form of small integers or deadline times, for example, and the priorities indicate the preferred order for execution of the jobs. Unfortunately, most systems suffer from some degree of priority inversion where a high priority job must wait for a lower priority job to execute. The authors consider the nature of the nonpreemptible code sections, called critical sections or critical regions, which give rise to this priority inversion in the context of a soft real-time operating system where average response time for different priority classes is the primary performance metric. An analytical model is described which is used to illustrate how critical regions may affect the time-constrained jobs in a multimedia (soft real-time) task set.
800C8759	Hardware task placements in dynamically reconfigurablelogic need to satisfy different goals such as highplacement efficiency, low fragmentation of the reconfigurable logic, and minimization of routing resources. There have been several placement algorithms proposed for each goal. Nevertheless, the algorithm can only satisfy one goal, which results in poor results in the other goal satisfactions. We propose a novel Multi-Objective Hardware Placement (MOHP) method such that all goals are satisfied and if there are conflicts a good trade off is obtained. MOHP is similar to share-based schedulers that try to adjust resource utilizationsamong different scheduling methods by varying the processorbandwidth. By applying MOHP to some examples, we find thatMOHP approximates the best performance for each assessmentcriterion.
80DD419F	Existing real-time ORB middleware standards such as RT-CORBA do not adequately address the challenges of 1) providing robust performance guarantees portably across different platforms, and 2) managing unpredictable workload. To overcome this limitation, we have developed software called FCS/nORB that integrates a Feedback Control real-lime Scheduling (FCS) service with the nORB small-footprint real-time ORB designed for networked embedded systems. FCS/nORB features feedback control loops that provide real-time performance guarantees by automatically adjusting the rate of remote method invocations transparently to an application. FCS/nORB thus enables real-time applications to be truly portable in terms of real-time performance as well as functionality, without the need for hand tuning. This paper presents the design, implementation, and evaluation of FCS/nORB. Our extensive experiments on a Linux testbed demonstrate that FCS can provide deadline miss ratio and utilization guarantees in face of changes in the platform and task execution times, while introducing a small amount of overhead.
7E3567FA	As real-time systems are moving form centralized architectures to distributed and Internet-based ones, global task scheduling and resource management have been the central issues. However, the current resource management techniques are based on fixed methods and hard to be extended. This paper develops a resource management framework with flexible, reusable and extensible resource management infrastructure by extending the methods provided in the real-time CORBA (RT-CORBA). The application of this framework is described in the design and implementation of an Internet-based distributed real-time system, in which a set of control nodes is distributively connected to the Internet. The system is designed for integrating multiple-platforms into the common protocol of the Internet, which extends the architecture and technology of conventional bus-based or dedicated communication-channel-based distributed systems. The client server of any node can monitor or control the status of other remote nodes in the system. Various optimizations are adopted in order to enhance the real-time performance of this system.
77B88F5B	This paper outlines the design objectives and research goals for HARTOS, a distributed real-time operating system being developed at The University of Michigan. This effort is part of a larger research project to design and implement an experimental distributed real-time system called the Hexagonal Architecture for Real-Time Systems (HARTS). An important feature of HARTS is the use of an intelligent network processor to handle many of the functions relating to communications. The paper focuses on the communications aspects of the operating system and the control software kernel of the network processor. The preliminary version of the kernel provides good support for inter-process communication and distributed control. Its performance has been measured and analyzed and found to be comparable to that of other message passing systems like the V system.
7FD63100	There is increasing demand to extend Object RequestBroker (ORB) middleware to support distributed applications withstringent real-time requirements. However, conventional ORB implementations,such as CORBA ORBs, exhibit substantial priority inversion andnon-determinism, which makes them unsuitable for applicationswith deterministic real-time requirements. This paper providestwo contributions to the study and design of real-time ORB middleware.First, it illustrates empirically why conventional ORBs do notyet support real-time quality of service. Second, it evaluatesconnection and concurrency software architectures to identifystrategies that reduce priority inversion and non-determinismin real-time CORBA ORBs. The results presented in this paperdemonstrate the feasibility of using standard OO middleware likeCORBA to support certain types of real-time applications overthe Internet.
7ABD83C3	In this paper we propose and evaluate a methodology for run-time fast software component migration for application survivability in distributed real-time systems. For fast migration we focus on the two dominant factors; lightweight migration and proactive resource discovery. The former is to minimize the absolute amount of time required for migration and the latter is to provide a destination host information at the time of migration decision. The run-time software component is implemented as Java object whose class is defined by extending the unicast remote server class. The proactive resource discovery consists of Community protocol and associated algorithms. These two ideas have been implemented as a middleware that also provides a real-time job scheduler in JVM (Java Virtual Machine), and a naming server. Our analysis and simulation in a cluster computing environment show that the proactive resource discovery requires very low communication overhead while maintaining high effectiveness in finding available CPU resources. Our implementation and measurement show that run-time component migration based on our approach takes much less time compared to the approach based on reactive resource discovery
5E522BB9	Packet processing systems of forthcoming high-speed network nodes demand extremely high processing rates, but also modularity and easy adaptability due to new or evolving protocols and services. As the fixed architecture and instruction set of current network processors sometimes hinders an efficient implementation of processing tasks, we introduced the MIXMAP architecture [4] that is designed to offer programmability at multiple levels of abstraction. Now we describe the prototypical realization of this architecture showing its feasibility. Our results indicate that up to 170 million packets per second can be processed with this architecture using current FPGAs. By implementing packet processing tasks at register-transfer level and at software level, we validate the architecture's applicability and the benefits of implementing at an appropriate level of abstraction.
7F447BA2	Summary form only given. We propose architecture and a general optimization framework for dynamic, distributed real-time systems. Interesting features of this model include the consideration of adaptive applications and utility functions. We extend by formalizing the corresponding multicriterial optimization problem. As the most difficult part of this problem, we identified the evaluation and comparison of the quality of single allocations and sets of allocations, respectively. To this end, we propose and examine metrics for measuring the goodness of solutions within our general resource management framework. These metrics lay the basis for further work on developing both online and offline algorithms to tackle the general optimization problem and provide an efficient adaptive resource manager for dynamic, distributed real-time systems.
7EFCA914	The recent proliferation of ever smaller and smarter electronic devices, combined with the introduction of wireless communication and mobile software technologies enables the construction of a large variety of pervasive applications, such as home supervision and alarm systems. The inherent complexity of such applications along with their nonexpert clientele raises the necessity for Autonomic Management solutions. Nonetheless, such solutions remain difficult to conceive, as they must deal with the increased volatility, heterogeneity and distribution of the pervasive domain, while ensuring stringent performance and dependability requirements. This paper proposes that reusable support for Autonomic Management solutions be provided by middleware platforms, along with already existing middleware services, such as security and transactions. Following this approach, a service oriented component platform, iPOJO, was extended with elementary Autonomic Management capabilities. These include monitoring and effector touch points, as well as embedded Autonomic Management functions, such as service dependency management. IPOJO is an open source Apache project and has been successfully employed to implement several research projects inthe pervasive domain. This paper presents iPOJO’s extension with reusable Autonomic Management middleware services.
7D31AD48	Real-time software systems are rarely developed once and left to run. They are subject to changes of requirements as the applications they support expand, and they commonly outlive the platforms they were designed to run on. A successful real-time system is duplicated and adapted to a variety of applications - it becomes a product line. Current methods for real-time software development are commonly based on low-level programming languages and involve considerable duplication of effort when a similar system is to be developed or the hardware platform changes. To provide more dependable, flexible and maintainable real-time systems at a lower cost what is needed is a platform-independent approach to real-time systems development. The development process is composed of two phases: a platform-independent phase, that defines the desired system behaviour and develops a platform-independent design and implementation, and a platform-dependent phase that maps the implementation onto the target platform. The last phase should be highly automated. For critical systems, assessing dependability is crucial. The partitioning into platform dependent and independent phases has to support verification of system properties through both phases.
7ED7CD4F	Many real-world distributed, real-time, embedded (ORE) systems, such as multiagent military applications, are built using commercially available operating systems, middleware, and collections of pre-existing software. The complexity of these systems makes it difficult to ensure that they maintain high quality of service (QOS). At design time, the challenge is to introduce coordinated QOS controls into multiple software elements in a non-invasive manner. At run time, the system must adapt dynamically to maintain high QOS in the face of both expected events, such as application mode changes, and unexpected events, such as resource demands from other applications. We describe the design and implementation of a CPU broker for these types of ORE systems. The CPU broker mediates between multiple real-time tasks and the facilities of a real-time operating system: using feedback and other inputs, it adjusts allocations over tune to ensure that high application-level QOS is maintained. The broker connects to its monitored tasks in a non-invasive manner, is based on and integrated with industry-standard middleware, and implements an open architecture for new CPU management policies. Moreover, these features allow the broker to be easily combined with other QOS mechanisms and policies, as part of an overall end-to-end QOS management system. We describe our experience in applying the CPU Broker to a simulated DUE military system. Our results show that the broker connects to the system transparently and allows it to function in the face of run-time CPU resource contention.
5BC89B7B	Efficient and predictable demultiplexing is necessary to provide real-time support for distributed object computing applications developed with CORBA. This paper presents two contributions to the study of demultiplexing for real-time CORBA endsystems. First, we present an empirical study of four CORBA request demultiplexing strategies (linear search, perfect hashing, dynamic hashing, and active demultiplexing) for a range of target objects and operations. Second, we describe our use of the perfect hashing and active demultiplexing strategies to develop a high-performance, real-time object request broker (ORB) called TAO.
7C81A5DC	Increasing quality-of-service requirements pose challenges in both design and optimization for real time CORBA middleware. The authors describe TAO (The Ace ORB), an object request broker that provides end-to-end QoS guarantees. In discussing TAO, we focus on object-adapter and ORB-core optimizations in three key dimensions in high performance, real time ORB end system design: server-side concurrency, memory management, and CORBA request demultiplexing.
5FD1FEB6	The FlexiNet Platform is a Java middleware platform that features a component based internal structure with strong emphasis placed on reflection and introspection at all levels. This allows programmers to tailor the platform for a particular application domain or deployment scenario by assembling strongly typed components. In this paper we give an overview of the FlexiNet architecture, highlighting how its approach differs from other middleware architectures, and illustrate the benefits that result from the new approach.

7A2E21CE	To be an effective platform for performance-sensitive real-time systems, commodity-off-the-shelf (COTS) distributed object computing (DOC) middleware must support application quality of service (QoS) requirements end-to-end. However, conventional COTS DOC middleware does not provide this support, which makes it unsuited for applications with stringent latency, determinism, and priority preservation requirements. It is essential, therefore, to develop standards-based, COTS DOC middleware that permits the specification, allocation, and enforcement of application QoS requirements end-to-end.The real-time CORBA and messaging specifications in the CORBA 2.4 standard are important steps towards defining standards-based, COTS DOC middleware that can deliver end-to-end QoS support at multiple levels in distributed and embedded real-time systems. These specifications still lack sufficient detail, however, to portably configure and control processor, communication, and memory resources for applications with stringent QoS requirements.
5DD3CA36	In this article we present a detailed theoretical analysis of the behavior of our artificial hormone system. The artificial hormone system (AHS) is part of an organic middleware for mapping tasks on an heterogeneous grid of processing elements. The AHS works completely decentral - each processing cell decides for itself if it is best suited for a task and interacts with the other processing cells via ”hormone” messages. As there is no central element the stability of the system can not be controlled by a single processing element, instead the hormone values have to be chosen carefully to guarantee system stability. We will present upper and lower bounds which have to be met to guarantee system stability.
7F7E1DC6	Improving real-time is one of the most essential problems in studies of real-time operating system (RTOS). The time of task context switching is an important factor that affects the real-time of RTOS. This paper concentrates on the improvement of task context switching of one kind of RTOS-OSEK operating system. According to different task states, we apply different context switching strategies to reduce the average time of context switching. This method has been successfully implemented and evaluated in our OSEK compatible operating system-SmartOSEK OS.
7AC411E4	There is increasing demandto extend CORBA middleware to support applications with stringentquality of service (QoS) requirements. However, conventionalCORBA middleware does not define standard features to dynamicallyschedule operations for applications that possess deterministicreal-time requirements. This paper presents three contributionsto the study of real-time CORBA operation scheduling strategies.First, we document our evolution from static to dynamic schedulingfor applications with deterministic real-time requirements. Second,we describe the flexible scheduling service framework in ourreal-time CORBA implementation, TAO, which supports core schedulingstrategies efficiently. Third, we present results from empiricalbenchmarks that quantify the behavior of these scheduling strategiesand assess the overhead of dynamic scheduling in TAO. Our empiricalresults using TAO show that dynamic scheduling of CORBA operationscan be deterministic and can achieve acceptable latency for operations,even with moderate levels of queueing.
7D5EE7EB	Distributed object computing middleware such as CORBA, RMI, and DCOM have gained wide acceptance and has shielded programmers from many tedious and error-prone aspects of distributed programming. In particular, CORBA event service has been used extensively in embedded systems. We propose an aspect oriented approach to develop synchronization code for distributed systems that use event service as the underlying communication middleware. Our approach is to factor out synchronization as a separate aspect, synthesize synchronization code and then compose it with the functional code. We use high-level "global invariants" to specify the synchronization policies which are then automatically translated into synchronization code for the underlying event service. To implement synchronization efficiently using the event service, we propose enhancements to the semantics of the event service. Specifically, we define the notion of condition events and exactly k semantics. Given these enhancements, we describe a synthesis procedure to translate global invariants into synchronization code based on events. We describe the implementation of the enhancements on the Tao's Real-Time Event Service. We present experimental results to demonstrate that the enhanced event service leads to more efficient implementation of synchronization. We feel that our methodology and the enhanced Real-Time Event Service will lead to more confident use of sophisticated synchronization policies in distributed object oriented systems.
75AF2650	The end-to-end performance of pervasive mobile systems is commonly dictated by the availability of resources at the weakest link. However, a number of run-time adaptations or morphing steps can be performed to tune the system performance. In this paper, we present M-ECho, a middleware for system morphing. M-ECho is designed with focus on data streaming applications, specifically in the field of pervasive mobile systems. We consider an autonomous robotics application comprising of a set of cooperating mobile robots to demonstrate and evaluate M-ECho's system morphing capabilities. Optimizations are based upon metrics of average instantaneous power consumption at a single node (local) as well as the power consumed by all participants (global). Experimental results show that M-ECho is able to achieve improved end-to-end performance with its dynamic code morphing techniques.