5E824C4A	Software architecture descriptions are high-level models of software systems. Most existing special-purpose architectural notations have a great deal of expressive power but are not well integrated with common development methods. Conversely, mainstream development methods are accessible to developers, but lack the semantics needed for extensive analysis. In our previous work, we described an approach to combining the advantages of these two ways of modeling architectures. While this approach suggested a practical strategy for bringing architectural modeling into wider use, it introduced specialized extensions to a standard modeling notation, which could also hamper wide adoption of the approach. This paper attempts to assess the suitability of a standard design method “as is” for modeling software architectures.
7F412202	Software managers need to have information in order to control a software development process. One way to get this information is using data from old software projects. When this information is not available, software managers can not make precise plans to develop software. In this paper we are going to present an intelligent system that given the estimated software size in Function Points (FP) or in Source Lines of Code (SLOC), it will determine the staff, schedule, effort, and paperwork needed to complete the software life cycle (Analysis, Feasibility, Design, Implementation, Integration, and Testing). The system will also estimate how many defects will be expected during the software life cycle. With this information, software managers can make appropriate plans to develop software.
77C8DE95	Software engineers rely on program documentation as an aid in understanding the functional nature, high-level design, and implementation details of complex applications. However, no one really knows what types of documentation are truly useful to software engineers to aid system understanding. This workshop focuses on issues related to this fundamental problem, such as what formats the documentation should take, who should produce it, and when. The juxtaposition of a technical communication audience with software engineering researchers and practitioners will provide new insights into the problem.
80FB6B66	An information retrieval technique, latent semantic indexing, is used to automatically identify traceability links from system documentation to program source code. The results of two experiments to identify links in existing software systems (i.e., the LEDA library, and Albergate) are presented. These results are compared with other similar type experimental results of traceability link identification using different types of information retrieval techniques. The method presented proves to give good results by comparison and additionally it is a low cost, highly flexible method to apply with regards to preprocessing and/or parsing of the source code and documentation.
7DDD1E4E	This paper presents the findings of a survey on the use of UML in software maintenance, carried out with 178 professionals working on software maintenance projects in 12 different countries. As part of long-term research we are carrying out to investigate the benefits of using UML in software maintenance, the main objectives of this survey are: 1) to explore whether UML diagrams are being used in software industry maintenance projects; 2) to see what UML diagrams are the most effective for software maintenance; 3) to find out what the perceived benefits of using UML diagrams are; and 4) to contextualize the kind of companies that use UML documentation in software maintenance. Some complementary results based on the way the documentation is used (whether it is UML-based or not) during software maintenance are also presented.
81B5134E	Focuses on investigating the combined use of semantic and structural information of programs to support the comprehension tasks involved in the maintenance and reengineering of software systems. "Semantic information" refers to the domain-specific issues (both the problem and the development domains) of a software system. The other dimension, structural information, refers to issues such as the actual syntactic structure of the program, along with the control and data flow that it represents. An advanced information retrieval method, latent semantic indexing, is used to define a semantic similarity measure between software components. Components within a software system are then clustered together using this similarity measure. Simple structural information (i.e. the file organization) of the software system is then used to assess the semantic cohesion of the clusters and files with respect to each other. The measures are formally defined for general application. A set of experiments is presented which demonstrates how these measures can assist in the understanding of a nontrivial software system, namely a version of NCSA Mosaic.
7F5143D2	The Unified Modeling Language (UML) is the de facto standard for object-oriented software analysis and design modeling. However, few empirical studies exist that investigate the costs and evaluate the benefits of using UML in realistic contexts. Such studies are needed so that the software industry can make informed decisions regarding the extent to which they should adopt UML in their development practices. This is the first controlled experiment that investigates the costs of maintaining and the benefits of using UML documentation during the maintenance and evolution of a real, non-trivial system, using professional developers as subjects, working with a state-of-the-art UML tool during an extended period of time. The subjects in the control group had no UML documentation. In this experiment, the subjects in the UML group had on average a practically and statistically significant 54% increase in the functional correctness of changes (p=0.03), and an insignificant 7% overall improvement in design quality (p=0.22) - though a much larger improvement was observed on the first change task (56%) - at the expense of an insignificant 14% increase in development time caused by the overhead of updating the UML documentation (p=0.35).
7F4B8C8F	The field of software documentation is reviewed by examining manual writing before and after 1985. Changes in the field include an increased emphasis on satisfaction of users, improved management strategies and improved design techniques. Three books on software documentation published since 1988 are surveyed, and it is argued that the trends after 1985 reinforce a social constructionist view of documentation.
7E2B7A9B	The project METAMORPHOS is a two-year Italian research project, funded by the Ministry of University and Research, aimed at facilitating the selection and the adoption of reverse engineering and migration techniques and tools in industry. To pursue such an objective, the project aims at empirically evaluating techniques and tools that can potentially fulfill industry needs. The project focuses in particular on migration activities towards distributed architectures-such as Web-based and service-oriented-and mobile devices that are nowadays gaining an increasing diffusion and central role.
806DBF3A	The Sixth International Workshop on Traceability in Emerging Forms of Software Engineering (TEFSE 2011) will bring together researchers and practitioners to examine the challenges of recovering and maintaining traceability for the myriad forms of software engineering artifacts, ranging from user needs to models to source code. The objective of the 6th edition of TEFSE is to build on the work the traceability research community has completed in identifying the open traceability challenges. In particular, it is intended to be a working event focused on discussing the main problems related to software artifact traceability and propose possible solutions for such problems. Moreover, the workshop also aims at identifying key issues concerning the importance of maintaining the traceability information during software development, to further improve the cooperation between academia and industry and to facilitate technology transfer.
7C1BAA8B	How can organizational factors such as structure and culture have an impact on the working conditions of developers? This study is based on ten months of observation of an in-house software development project within a large telecommunications company. The observation was conducted during mandatory weekly status meetings, where technical and managerial issues were raised and discussed. Preliminary results show that many decisions made under the pressure of certain organizational factors negatively affected software quality. This paper describes cases depicting the complexity of organizational factors and reports on ten issues that have had a negative impact on quality, followed by suggested avenues for corrective action.
597F1F45	The contribution of formal modeling approaches in software development has always been a subject of debates. The proponents of model-driven development argue that big upfront designs although require substantial investment will payoff later in the implementation phase in terms of increased productivity and quality. On the other hand, software engineers who are not very keen on modeling perceive the activity as simply a waste of time and money without any real contribution to the final software product. Considering present advancement of model-based software development in software industry, we are challenged to investigate the real contribution of modeling in software development. Therefore, in this paper we report on an empirical investigation on the impact of UML modeling on the quality of software system. In particular, we focus on defect density as a measure of software quality. Based on a significant industrial case study, we have found that the use of UML modeling potentially reduces defect density in software system.
7C8C5DFC	The language PL360, together with its phrase structure grammar, is used as a concrete basis for illustrating an idea called syntax-directed documentation. This idea is: (1) to use the phrase structure of a program to define the structure of a formal documentation for that program; (2) to use the syntactic types and identifiers in the resulting structure to trigger the automatic formation of questions to the programmer, whose answers will become part of that documentation; and (3) to provide automatic storage and retrieval facilities so that other programmers who want to understand or modify the program can access the resulting documentation, which is cross-indexed in various ways by syntactic types and objects. A small PL360 program, already found in the literature, is worked out as an example.
7A94C4AC	The Unified Modeling Language (UML) is an object-oriented analysis and design language widely used to created artifacts during the software system lifecycle. UML being a standard notation, without specific guidelines as to how to use it, it must be applied in the context of a specific software development process. The Unified Process (UP) is one such process, extensively used by the object-oriented community, which delivers software best practices via guidelines for all software lifecycle activities. The UP suggests many artifacts to be produced during the software lifecycle. But many practitioners are reluctant to use those artifacts as they question their benefits. System Sequence Diagrams and System Operation Contracts are artifacts, suggested by Larman in his well-known methodology, to complement standard UP artifacts with the intent of better understanding the input and output events related to the system being designed. This paper presents the results of controlled experiments that investigate the impact of using these artifacts during software development. One way to do that is to study the extent to which those artifacts improve the quality of the Domain Model or reduce the effort necessary to complete this Domain Model. Results show that the use of those artifacts mildly improves the quality of the Domain Model, as long as sufficient training is provided. On the other hand, there is no noticeable evidence that those two artifacts reduce the time to produce the Domain Model.
79D4DFB3	Software development activities face several challenges when they take place in geographically distributed settings. These challenges are often related to communication, collaboration and, especially, information diffusion among team members. This is especially important in impact analysis activities where all stakeholders need to align their work to understand the impact of a change. To properly support this, it is necessary to understand the different ways in which impact analysis activities are performed. In our previous work we identified two views of impact analysis: an organizational and an individual view. The first view is important for managers to understand the impact of the changes in the activities of the team, whereas the second refers to the developers' strategies to deal with the impact of changes in their daily work. This paper discusses these views and based on them describes a tool, called Wolf, to support impact analysis activities. Our tool, based on semi-automatically generated traceability links, provides different visualizations to support communication, collaboration and information diffusion among stakeholders thereby facilitating impact analysis activities in geographically distributed settings.
75FFFC30	Although various success stories of model-based approaches are reported in literature, there is still a significant resistance to model-based development in many software organizations because the UML is perceived to be expensive and not necessarily cost-effective. It is also important to gather empirical evidence in which context and under which conditions the UML makes or does not make a practical difference.Our objective is to provide empirical evidence as to which UML diagrams are more helpful during software maintenance: Forward Designed (FD) UML diagrams or Reverse Engineered (RE) UML diagrams.We carried out a family of experiments which consisted of one experiment and two replications with a total of 169 Computer Science undergraduate students.The individual data analysis and the meta-analysis conducted on the whole family, show a tendency in favor of FD diagrams and are significantly different as regards the effectiveness and efficiency of the subjects who participated and played the role of maintainers. The analysis of the qualitative data, collected using a post-experiment survey, reveals that the subjects did not consider RE diagrams helpful.Our findings show that there are some objective results (descriptive statistics or statistical tests) related to the maintenance effectiveness and efficiency in favor of the use of FD UML diagrams during software maintenance. Subjective opinions also lead us to recommend the use of UML diagrams (especially class diagrams) created during the design phase for software maintenance because they improve the understanding of the system in comparison with RE diagrams. Nevertheless, we can only assume that these results are valid in the context of Computer Science undergraduate students when working with small systems related to well-known domains, and other contexts should be explored in order to reaffirm the results in an industrial context by carrying out replications with professionals.
7BDA9AF8	We carried out a family of experiments to investigate whether the use of UML models produced in the requirements analysis process helps in the comprehensibility and modifiability of source code. The family consists of a controlled experiment and 3 external replications carried out with students and professionals from Italy and Spain. 86 participants with different abilities and levels of experience with UML took part. The results of the experiments were integrated through the use of meta-analysis. The results of both the individual experiments and meta-analysis indicate that UML models produced in the requirements analysis process influence neither the comprehensibility of source code nor its modifiability.
7D3D1228	The paper describes the initial results of applying Latent Semantic Analysis (LSA) to program source code and associated documentation. Latent Semantic Analysis is a corpus-based statistical method for inducing and representing aspects of the meanings of words and passages (of natural language) reflective in their usage. This methodology is assessed for application to the domain of software components (i.e., source code and its accompanying documentation). The intent of applying Latent Semantic Analysis to software components is to automatically induce a specific semantic meaning of a given component. Here LSA is used as the basis to cluster software components. Results of applying this method to the LEDA library and MINIX operating system are given. Applying Latent Semantic Analysis to the domain of source code and internal documentation for the support of software reuse is a new application of this method and a departure from the normal application domain of natural language.
7D5A8C13	During its lifecycle, software experiences numerous changes that are either due to bug fixes or to the incorporation of new features. Implementing such changes is often more difficult than expected, which frequently leads to underestimation of the associated implementation effort. This paper describes work that aims to understand change impact based on the visualization of the characteristics of change requests using standard diagrams (e.g. UML diagrams). Each diagram depicts different aspects of a software system and can illustrate factors that might drive the implementation effort. Using examples, in which we analyze three change requests, we describe how we determined the characteristics of the change requests. We furthermore discuss how the impact of change requests on diagrams relates to the implementation effort. Our overall goal is to develop a new impact analysis approach that helps determine software change impact based on the use of specific diagrams
7734A618	This paper presents a research proposal on how and why we are investigating the benefits of the Unified Modelling Language (UML) in software maintenance tasks. The principal objective is to present the main research questions, along with an explanation of which research methods we propose to use to obtain the answers to these questions in an empirical manner.
7F23FE81	A typical approach to software maintenance is analyzing just the source code, applying some patches, releasing the new version, and then updating the documentation. This quick-fix approach usually leads to documentation not aligned with the current system and degrades the original system structure, thus rendering the evolution of the system costly and error-prone. Although there are alternative maintenance models which avoid these problems, by analyzing and updating the system documentation first, the quick-fix approach continues to be popular because of the time pressure for new releases and the resistance to change of maintenance programmers. In this paper, we propose an iterative reengineering model which can be run each time the maintainability and reliability of a software system degrade under a tolerance level. The reengineering process, applied after a number of modifications, can result in renovation of the current system or simply in realignment of the documentation. In this context, reengineering is no longer a one-shot process but becomes an ordinary process which runs concurrently with the quick-fix maintenance process. The results obtained with an industrial case study are presented and the lessons learned are discussed.
7DC42E05	The paper describes the results of applying Latent Semantic Analysis (LSA), an advanced information retrieval method, to program source code and associated documentation. Latent semantic analysis is a corpus based statistical method for inducing and representing aspects of the meanings of words and passages (of natural language) reflective in their usage. This methodology is assessed for application to the domain of software components (i.e., source code and its accompanying documentation). Here LSA is used as the basis to cluster software components. This clustering is used to assist in the understanding of a nontrivial software system, namely a version of Mosaic. Applying latent semantic analysis to the domain of source code and internal documentation for the support of program understanding is a new application of this method and a departure from the normal application domain of natural language.
807BAAFB	 In order to find out the state of software maintenance in Hong Kong, we have conducted a questionnaire survey, supplemented by telephone interviews and industrial visits. Our results indicate that, in Hong Kong, about 66% of the total software life cycle cost is spent on software maintenance. The average application system is about 5.1 years old, consisting of 577 programs and 308,000 lines of code. The most often cited problems in software maintenance are staff turnover, poor documentation and changing user requirements. We also observed that software maintenance work has not been given proper recognition. This paper attempts to contrast our survey findings with that of a similar survey conducted in USA. We also present some initial results of a series of experiments to compare OO with 4GL and conventional development approaches.
7FF0E7E6	The Unified Modeling Language (UML) is becoming the de facto standard for software analysis and design modeling. However, there is still significant resistance to model-driven development in many software organizations because it is perceived to be expensive and not necessarily cost-effective. Hence, it is important to investigate the benefits obtained from modeling. As a first step in this direction, this paper reports on controlled experiments, spanning two locations, that investigate the impact of UML documentation on software maintenance. Results show that, for complex tasks and past a certain learning curve, the availability of UML documentation may result in significant improvements in the functional correctness of changes as well as the quality of their design. However, there does not seem to be any saving of time. For simpler tasks, the time needed to update the UML documentation may be substantial compared with the potential benefits, thus motivating the need for UML tools with better support for software maintenance
7CB7F8D7	The Unified Modeling Language (UML) is a family of design notations that is rapidly becoming a de facto standard software design language. UML provides a variety of useful capabilities to the software designer, including multiple, interrelated design views, a semiformal semantics expressed as a UML meta model, and an associated language for expressing formal logic constraints on design elements. The primary goal of this work is an assessment of UML's expressive power for modeling software architectures in the manner in which a number of existing software architecture description languages (ADLs) model architectures. This paper presents two strategies for supporting architectural concerns within UML. One strategy involves using UML "as is," while the other incorporates useful features of existing ADLs as UML extensions. We discuss the applicability, strengths, and weaknesses of the two strategies. The strategies are applied on three ADLs that, as a whole, represent a broad cross-section of present-day ADL capabilities. One conclusion of our work is that UML currently lacks support for capturing and exploiting certain architectural concerns whose importance has been demonstrated through the research and practice of software architectures. In particular, UML lacks direct support for modeling and exploiting architectural styles, explicit software connectors, and local and global architectural constraints.
7E9CC159	traceMaintainer is a tool that supports an approach for maintaining post-requirements traceability relations after changes have been made to traced model elements. The update of traceability relations is based upon predefined rules, where each rule is intended to recognize a development activity applied to a model element. Little manual effort or interaction with the developer is required. traceMaintainer can currently be used with a number of commercial software development tools and enables the update of traceability relations stored within these tools. This paper provides an overview of traceMaintainer's architecture and major components.
7A36EB5E	Software architecture design documentation should communicate design decisions effectively. However, little is known about the way recipients respond to the different types of media used in documentation. We therefore conducted a controlled experiment to study whether visual or textual artifacts are more effective in communicating architecture software design decisions to software developers. Our participant group consisted of 47 participants from both industry and academia. Our results show that neither diagrams nor textual descriptions proved to be significantly more efficient in terms of communicating software architecture design decisions. Remarkably, participants who predominantly used text, scored significantly better, overall and with respect to topology related questions. Furthermore, surprisingly, diagrams were not able to alleviate the difficulties participants with a native language other than English had in extracting information from the documentation. In combination, these findings at the very least question the role of diagrams in software architecture documentation.
81223C97	An accurate set of traceability relations between software development artifacts is desirable to support evolutionary development. However, even where an initial set of traceability relations has been established, their maintenance during subsequent development activities is time consuming and error prone, which results in traceability decay. This paper focuses solely on the problem of maintaining a set of traceability relations in the face of evolutionary change, irrespective of whether generated manually or via automated techniques, and it limits its scope to UML-driven development activities post-requirements specification. The paper proposes an approach for the automated update of existing traceability relations after changes have been made to UML analysis and design models. The update is based upon predefined rules that recognize elementary change events as constituent steps of broader development activities. A prototype traceMaintainer has been developed to demonstrate the approach. Currently, traceMaintainer can be used with two commercial software development tools to maintain their traceability relations. The prototype has been used in two experiments. The results are discussed and our ongoing work is summarized.
7F8651AD	Modern large-scale software development is a complex undertaking and coordinating various processes is crucial to achieve efficiency. The alignment between requirements and test activities is one very important aspect. Production and maintenance of software result in an ever-increasing amount of information. To be able to work efficiently under such circumstances, navigation in all available data needs support. Maintaining traceability links between software artifacts is one approach to structure the information space and support this challenge. Many researchers have proposed traceability recovery by applying information retrieval (IR) methods, utilizing the fact that artifacts often have textual content in natural language. Case studies have showed promising results, but no large-scale in vivo evaluations have been made. Currently, there is a trend among our industrial partners to move to a specific new software engineering tool. Their aim is to collect different pieces of information in one system. Our ambition is to develop an IR-based traceability recovery plug-in to this tool. From this position, right in the middle of a real industrial setting, many interesting observations could be made. This would allow a unique evaluation of the usefulness of the IR-based approach.
760A508C	For most managers setting out to acquire a new MRP system for their company, the review and evaluation of product documentation is a critical first step in the acquisition and implementation process. Objective data is needed in order to narrow down the available alternatives. This study investigates how vendors describe and differentiate their products within their promotional literature, and what claims they make for them. Evaluation of documentation covering 69 manufacturing software products shows that vendors are (1) targeting products across very broad industry groups, (2) emphasizing service-related attributes in client relationships, but (3) are ignoring implementation issues, and (4) are failing to provide explicit advice to prospective users on potential costs and benefits.
79AEDE90	This  workshop  will demonstrate  and  explain  the creation  of  documentation  for  Aspect-Oriented programs   written   in   Java.   Fundamentals   of Aspect-Oriented   Programming,   separation   of concerns,  and  as  well  as  motivation  for  Aspect-Oriented Programming , will be presented.
7D52E96E	An approach to storing source code using a relational database is described. The goal of this approach is to assist in the maintenance of source code, especially in producing cross references documentation. Why this approach was chosen and how the system's architecture was set up are explained. The emphasis, however, is placed upon the results obtained by using this system, in terms of volume and response time.
7D935EA2	An intelligent, knowledge-based maintenance tool is described. The tool is intended to help reduce the amount of time spent on analyzing code. Code analysis is performed when a programmer is familiarizing himself with a piece of code and when the effects of a proposed modification of the code is being assessed. The research project is described, and its theoretical foundation is examined.
7BAA01F5	The importance of software documentation and the effects of poor documentation in data processing are often underrated. Little research has been published that evaluates the quality of software documentation. The evaluation of textual attributes such as comprehensibility, readability, etc., has seen more studies and relatively sound results. Thus this paper exclusively handles textual documentation, whereby the methods are employed for the evaluation of software documentation. We first introduce the methods used in the measurement of text comprehensibility. Then RMS (Readability Measuring System), a tool developed by the author to support the measuring process, is presented. The third part of the paper presents empirical results and discusses the experience gained in the application of the RMS tool.
806FB17F	Graphical documentation is often characterized as an effective aid in program understanding. However, it is an open question exactly which types of graphical documentation are most suitable for which types of program understanding tasks (and in which specific usage contexts). The Unified Modeling Language (UML) is the de facto standard for modeling modern software applications. This paper describes an experiment to assess the qualitative efficacy of UML diagrams in aiding program understanding. The experiment had participants analyze a series of UML diagrams and answer a detailed questionnaire concerning a hypothetical software system. Results from the experiment suggest that the UML's efficacy in support of program understanding is limited by factors such as ill-defined syntax and semantics, spatial layout, and domain knowledge.
7DD2EFFC	For anything but the simplest of software systems, the ease and costs associated with change management can become critical to the success of a project. Establishing traceability initially can demand questionable effort, but sustaining this traceability as changes occur can be a neglected matter altogether. Without conscious effort, traceability relations become increasingly inaccurate and irrelevant as the artifacts they associate evolve. Based upon the observation that there are finite types of development activity that appear to impact traceability when software development proceeds through the construction and refinement of UML models, we have developed an approach to automate traceability maintenance in such contexts. Within this paper, we describe the technical details behind the recognition of these development activities, a task upon which our automated approach depends, and we discuss how we have validated this aspect of the work to date.
5DB778AF	Model Driven Architecture (MDA) was born as a standard of Model Driven Development (MDD) to increment the productivity in the software industry. Actually, there exist different models based tools to get an acceptable degree of automation in the applications generation. Many of those tools allow users to build software with high productivity in their respective domains. According their authors, the very challenge of MDA approach and tools is to put emphasis in a satisfactory degree of productivity and, at the same time, increasing others important software qualities such as portability, interoperability, reusability and maintainability. This paper intends to verify the effectiveness of such benefits analyzing the development of a real application using a MDA tool compared with a traditional approach. For analysis purpose, a series of metrics that can help to evaluate the different aspects related to the benefits of MDA was adopted.
802BC80F	Traditionally, diagrams used in software systems modelling have been two dimensional (2D). This is probably because graphical notations, such as those used in object-oriented and structured systems modelling, draw upon the topological graph metaphor, which, at its basic form, receives little benefit from three dimensional (3D) rendering. This paper presents a series of 3D graphical notations demonstrating effective use of the third dimension in modelling. This is done by e.g. connecting several graphs together, or in using the Z co-ordinate to show special kinds of edges. Each notation combines several familiar 2D diagrams, which can be reproduced from 2D projections of the 3D model. 3D models are useful even in the absence of a powerful graphical workstation: even 2D stereoscopic projections can expose more information than a plain planar diagram.
7BBBFC44	When compared to traditional development methods, agile development practices are associated with more direct communication and less documentation. However, few empirical studies exist that investigate the role of documentation in agile development teams. We thus employed a questionnaire to measure the perceptions of a group of agile practitioners with regard to the documentation in their projects. We obtained responses from 79 agile software development professionals and 8 teams in 13 different countries. Our findings include that over half of developers in our data set find documentation important or even very important but that too little documentation is available in their projects. Agile practitioners do not seem to agree with the agile principle that "The most efficient and effective method of conveying information to and within a development team is face-to-face conversation." We were able to validate this result for a set of dissimilar agile teams in various domains.
7C056534	A Component Based System (CBS) is integration centric with a focus on selecting individual components that match stakeholder requirements. In reality, components are usually designed for general purposes and finding the ideal one is often very difficult. Fundamental to CBS success is the ability to minimize the mismatch between stakeholder expectations and functionality provided by available components. Recent research indicates that the Framework for Integrated Test (Fit), a test driven development, helps to better understand customer requirements. This paper presents an initial study to investigate the potential use of acceptance tests (Fit tables) during the component selection process. The analysis shows that Fit tables help improve the component selection phase of a CBS development life cycle.
7EBEFDF1	A KBRPS (knowledge-based rapid prototyping system) system for automated support of software documentation his been developed. KBRPS contains a graphic representation of a conceptual model for modeling system structures; a language, FSRSL (frame-based software requirements specification language) for describing the textual form of the conceptual model and further specifying detailed system behaviors; a database for stored specifications files; and a knowledge base for stored rules of software development. The FSRSL specifications stored in the database can be retrieved by a query system for generating formal documents. These documents, which are helpful for understanding the maintained system, include the conceptual model, the FSRSL specifications, the abstract relations of hierarchical specifications, and even the answers to particular questions.
7D0A7A81	The importance of accurate technical documentation to the maintenance process is presented. A possible solution to the lack of adequate technical documentation is suggested in the form of a partially automated in-line documentation system. This system uses software metrics to determine where comments should be placed in source programs. The system can be used as a tool in software development and/or software maintenance.
7D001A43	Automated code generators are increasingly used in safety-critical applications, but since they are typically not qualified, the generated code must still be fully tested, reviewed, and certified. For mathematical and engineering software this requires reviewers to trace subtle details of textbook formulas and algorithms to the code, and to match requirements (e.g., physical units or coordinate frames) not represented explicitly in models or code. We support these tasks by using the AutoCert verification system to identify and verify mathematical concepts in the code, recovering verified traceability links between concepts, code, and verification conditions. We then exploit these links to construct a natural language report that provides a high-level structured argument explaining where the code uses specified assumptions and why and how it complies with the requirements. We have applied our approach to generate review documents for several sub-systems of NASA's Project Constellation.
7E96AE65	Programmers often use graphical forms of documentation that rely on software visualization techniques to make complicated information easier to understand. However, it is an open question exactly which types of graphical documentation are most suitable for which types of program understanding tasks (and in which specific usage contexts). The Unified Modeling Language (UML) is the de facto standard for modeling modern software applications. This paper focuses on discussing techniques for the efficacy of UML diagrams in aid of program understanding. The majority of the workshop will involve participants analyzing a series of UML diagrams and answering a detailed questionnaire concerning a hypothetical software system.
7FCFB6D5	This paper focuses on documentation practices in scientific software development and takes into account two perspectives: that of scientists who develop software (scientists-developers) and of those scientists who use it. We describe documentation practices of scientists-developers. We also explore the role of users' community in scientific software documentation. We compare our findings to studies about documentation practices of professional software developers and discuss how production of documentation in scientific software development can be supported.
7E5BF652	A new metric for evaluating the cost effectiveness of technical reviews is described. The proposed metric is based on the degree to which testing costs are reduced by technical reviews. The metric can be interpreted as combining two conventional metrics. Using an experimental evaluation of the conventional metrics and the proposed metric for data collected in an industrial environment, the authors show the validity and usefulness of the proposed metric. In particular, they present a method to estimate a value of the proposed metric by using only the values obtained at review phase.
76677ED7	Agile and lean software development methodologies appear as a popular alternative to plan-driven methodologies, but these methodologies have no structure in the process of user requirements specification. This paper shows how Method for Elicitation, Documentation and Validation of Software User Requirements (MEDoV) supports agile and lean software development methodologies. The MEDoV helps stakeholders in their everyday work with minimal impact on agility. The method also ensures an active role of business users, a wide-picture what usually is the problem for agile development, and definition of non-functional requirements, what the even bigger problem is. The MEDoV ensures that no unnecessary features are produced so that no extra code is created, and maintenance is easier, as well as code correction and improvement. Using models enables agility in product maintenance, especially for integrated systems where one change can have multiple impacts on different parts of system.