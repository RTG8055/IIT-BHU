7D09D29E	In this paper, we present our approach for automatic SystemC code generation from UML models at early stages of Systems On Chip (SOC) design. A particularity of our proposed approach is the fact that SystemC code generation process is performed through two levels of abstraction. In the first level, we use UML hierarchic sequence diagrams to generate a SystemC code that targets algorithmic space exploration and simulation. In the second level of abstraction, messages that occur in sequence diagrams are implemented using UML activity diagrams whose actions are expressed in the C++ Action Language (AL) included in the Rhapsody environment from which a full SystemC code is generated for both simulation and synthesis.
5B6A5210	We give a new description of the so-called hyperbolic codes from which the minimum distance and the generator matrix are easily determined. We also give a method for the determination of the dimension of the codes and finally some results on the weight hierarchy are presented.
7CCEC64C	The instruction-set of a target architecture is represented as a set of attribute-grammar productions. A code generator is obtained automatically for any compiler using attributed parsing techniques. A compiler built on this model can automatically perform most popular machine-dependent optimizations, including peephole optimizations. The code generator is also easily retargetable to different machine architectures.
7B6281C3	This paper discusses algorithms which transform expression trees into code for register machines. A necessary and sufficient condition for optimality of such an algorithm is derived, which applies to a broad class of machines. A dynamic programming algorithm is then presented which produces optimal code for any machine in this class; this algorithm runs in time linearly proportional to the size of the input.
7D46C75E	A concept for the automatic generation of opti- mization code for a class of non-linear optimization problems is described and realized at the example of an electric power system optimal power flow problem. The equations are structured based on a node and edge structure given from a network. The goal of this domain engineering approach is the high-level symbolic formulation of this structured op- timization problem and the subsequent complete automatic code generation of the solution algorithm in Matlab. The main algorithmic step is the iterative solution of a sparse lin- ear system of equations applied to the Karush-Kuhn-Tucker optimality conditions of the optimization problem. The ma- trix elements of this linear system to be solved during the solution process consist of sums of first and second order derivative terms of the original, high-level entered function parts. Applying this concept leads to a high quality domain software which seems to form a good compromise both for the developer and the software end-user organisation: High quality requirements can be satisfied with respect to speed, algorithmic robustness, easy core code (model) enhancement and maintenance capabilities for the developer and easy end- user model software parametrization.
7587A118	The problem of generating "optimal" programs for the evaluation of arithmetic expres- sions on a machine with a finite depth stack is studied. Efficient algorithms are given for constructing optimal programs in the case where the expressions are trees, there are no data dependencies, and the operators have limited algebraic properties.
7A487701	We propose a new family of asymptotically good binary codes, generalizing previous constructions of expander codes to t-uniform hypergraphs. We also describe an efficient decoding algorithm for these codes, that for a certain region of rates improves the known results for decoding distance of expander codes.The construction is based on hypergraphs with a certain “expansion” property called herein ϵ-homogeneity. For t-uniform t-partite Δ-regular hypergraphs, the expansion property required is roughly as follows: given t sets, A1,…,At, one at each side, the number of hyper-edges with one vertex in each set is approximately what would be expected had the edges been chosen at random. We show that in an appropriate random model, almost all hypergraphs have this property, and also present an explicit construction of such hypergraphs.Having a family of such hypergraphs, and a small code C0{0,1}Δ, with relative distance δ0 and rate R0, we construct “hypergraphs codes”. These have rate R0−(t−1), and relative distance ≥δ0t/(t−1)−o(1). When t=2l we also suggest a decoding algorithm, and prove that the fraction of errors that it decodes correctly is at least. In both cases, the o(1) is an additive term that tends to 0 as the length of the hypergraph code tends to infinity.
7564799E	We have constructed a local code generator for the VAX-112 using a parser-like instruction pattern matcher. The code generator replaces the second pass of the UNIX3 Portable “Crdquo; compiler. This paper describes the design of the code generator and the special considerations imposed by the pattern matching process. We summarize the structure of the machine description grammar and its associated semantic actions, as well as the tools we developed to manipulate the large VAX description. In our experience, this approach makes the instruction selection phase of the compiler easier and faster to implement, and more likely to be correct than traditional techniques.
7890E2BC	An automatic FORTRAN code generation and determination of energy eigenvalues for periodic potentials with wells and barriers are presented. These problems serve as test cases in developing tools and techniques for generation of numerically efficient FORTRAN software and for more general; efficient and flexible ways of programming. Several problems in different areas of science are described, and the advantages of the approach as well as limitations of the tools presently available are discussed.
80FE0294	Model driven software development, domain specific languages and other generative programming approaches have gained much attention. There is a large number of tools available, starting from simple code generators to full-blown tool suites. There are several success stories and process frameworks about applying full scale MDSD approaches, but there is no or little help for small-size projects. To fill this gap, we designed a new development process which targets small and middle size projects with limited resources. According to our experience the process is working efficiently in small projects even if they cannot afford bigger initial resource investment. In this experince report we document an industrial project in which the process was used. We present this process in the form which is applied in the first project and also discuss our experience and the limitations of the process.
8168E903	Minimum mean squared error (MMSE) fixed-lag smoothing is used in conjunction with DPCM (differential pulse code modulation) to develop a code generator employing delayed decoding. This smoothed DPCM (SDPCM) code generator is compared to DPCM and interpolative DPCM (IDPCM) code generators at rates 1 and 2 for tree coding several synthetic sources, as well as to a DPCM code/generator at rate 2 for speech sources. The (M,L) algorithm is used for tree searching, and SDPCM outperforms IDPCM and DPCM at rate 2 for synthetic sources with M=1, 4, 8, and 12, and at rate 1 with M>or=4. For speech, SDPCM provides a slight improvement in MSE (mean squared error) over DPCM codes, which is also evident in sound spectrograms and listening tests.
7CE0258A	This paper describes a tool called vpoiso that was developed to isolate errors automatically in the vpo compiler system. The two general types of compiler errors isolated by this tool are optimization and nonoptimization errors. When isolating optimization errors, vpoiso relies on the vpo optimizer to identify sequences of changes, referred to as transformations, that result in semantically equivalent code and to provide the ability to stop performing improving (or unnecessary) transformations after a specified number have been performed. A compilation of a typical program by vpo often results in thousands of improving transformations being performed. The vpoiso tool can automatically isolate the first improving transformation that causes incorrect output of the execution of the compiled programs by using a binary search that varies the number of improving transformation performed. Not only is the illegal transformation automatically isolated, but vpoiso also identifies the location and instant the transformation is performed in vpo. Nonoptimization errors occur from problems in the front end, code generator, and necessary transformations in the optimizer. If another compiler is available that can produce correct (but perhaps more inefficient) code, then vpoiso can isolate nonoptimization errors to a single function. Automatic isolation of compiler errors facilitates retargeting a compiler to a new machine, maintenance of the compiler, and supporting experimentation with new optimizations.
7E962882	Designing an efficient floating-point implementation of a function based on polynomial evaluation requires being able to find an accurate enough evaluation code, exploiting at most the target architecture features. This article introduces CGPE, a tool dealing with the generation of fast and certified codes for the evaluation of bivariate polynomials. First we discuss the issue underlying the evaluation scheme combinatorics before giving an overview of the CGPE tool. The approach we propose consists in two steps: the generation of evaluation schemes by using some heuristics so as to quickly find some of low latency, and the selection that mainly consists in automatically checking their scheduling on the given target and validating their accuracy. Then, we present on-going development and ideas for possible improvements of the whole process. Finally, we illustrate the use of CGPE on some examples, and show how it allows us to generate fast and certified codes in a few seconds and thus to reduce the development time of libms like FLIP.
80F84BF0	An algorithm is given to translate a relatively low-level intermediate representation of a program into assembly code or machine code for a target computer. The algorithm is table driven. A construction algorithm is used to produce the table from a functional description of the target machine. The method produces high quality code for many commercially available computers. By replacing the table, it is possible to retarget a compiler for another kind of computer. In addition techniques are given to prove the correctness of the translator.
77BC50F5	Digital signal processors provide specialized SIMD (single instruction multiple data) operations designed to dramatically increase performance in embedded systems. While these operations are simple to understand, their unusual functions and their parallelism make it difficult for automatic code generation algorithms to use them effectively. In this paper, we present a new optimizing code generation method that can deploy these operations successfully while also verifying that the generated code is a correct translation of the input program.
7E8DE245	Unlike for conventional compilers for imperative programming languages such as C or ADA, no establishedmethods for safeguarding artifacts generated by model-based code generators exist despite progress in the field of formalverification. Several test approaches dominate the engineering practice. This paper describes a general and toolindependenttest architecture for code generators used in model-based development. We evaluate the effectiveness of ourtest approach by means of testing optimizations performed by the TargetLink code generator, a widely accepted andcomplex development tool used in automotive model-based development.
78EE79D2	This paper presents some code generation issues in the context of the PQCC Production-Quality Compiler-Compiler project [8]. The approach taken is unusual in several ways. The machine-dependent information for selection of code sequences, register assignments, etc., has been separated throughout, in tabular form, from the machine-independent algorithms. This not only greatly simplifies the development of code generators for new machines or languages, but paves the way for automatic generation of these tables from formal machine descriptions such as ISP [1]. A parse-tree-like internal program representation is used, facilitating the use of context and data dependency information about expressions. The code generation process has been broken into several phases. This leads to simplification and better understanding of the code generation process, and also allows important improvements in the quality of generated code. The algorithms for preliminary determination of addressing modes, allocation of registers and other locations, and the code selection case analysis are dlscussed. The algorithms described In the paper are being implemented and used in the PQCC compiler.
7659FCEF	Affix grammars are used to describe the instruction set of a target architecture for purposes of compiler code generation. A code generator is obtained automatically for a compiler using attributed parsing techniques. A compiler built on this model can automatically perform most popular machine-dependent optimizations, including peephole optimizations. Code generators based on this model demonstrate retargetability for the VAX1-11, iAPX2-86, Z-80003, PDP4-11, MC-68000, NS32032, FOM, and IBM-370 architectures.
8614DF9E	We introduce the paradigm of schedule-carrying code (SCC). A hard real-time program can be executed on a given platform only if there exists a feasible schedule for the real-time tasks of the program. Traditionally, a scheduler determines the existence of a feasible schedule according to some scheduling strategy. With SCC, a compiler proves the existence of a feasible schedule by generating executable code that is attached to the program and represents its schedule. An SCC executable is a real-time program that carries its schedule as code, which is produced once and can be revalidated and executed with each use. We evaluate SCC both in theory and practice. In theory, we give two scenarios, of nonpreemptive and distributed scheduling for Giotto programs, where the generation of a feasible schedule is hard, while the validation of scheduling instructions that are attached to the programs is easy. In practice, we implement SCC and show that explicit scheduling instructions can reduce the scheduling overhead up to 35% and can provide an efficient, flexible, and verifiable means for compiling Giotto programs on complex architectures, such as the TTA.
7B6BC907	Production code generation with Model-Based Design has successfully replaced manual coding across various industries and application domains. Furthermore, code generated from executable graphical models is increasingly being deployed in high-integrity embedded applications.To validate the model-to-code translation process, generated software components and its precursory stages (i.e. models) should be subjected to an appropriate combination of quality assurance measures. For high-integrity applications, compliance with safety standards such as IEC 61508 needs to be demonstrated as well.On principle, translation validation of generated code could be carried out in the same manner as for manually written code. However, this would not leverage the advantages of Model-Based Design and w.r.t. process efficiency this would leave something to be desired. Therefore, engineering methods and tools for effective and efficient translation validation of generated code are highly desirable. As a step towards this goal, a workflow for verification and validation of models and generated code will be proposed and as far as possible mapped onto the objectives of IEC 61508-3. A cornerstone of this workflow is testing for numerical equivalence between models and generated code.
7C6E07EA	Work with compiler compilers has dealt principally with automatic generation of parsers and lexical analyzers. Until recently, little work has been done on formalizing and generating the back end of a compiler, particularly an optimizing compiler. This paper describes formalizations of machines and code generators and describes a scheme for the automatic derivation of code generators from machine descriptions. It was possible to separate all machine dependence from the code generation algorithms for a wide range of typical architectures (IBM-360, PDP-11, PDP-10, Intel 8080) while retaining good code quality. Heuristic search methods from work in artificial intelligence were found to be both fast and general enough for use in generation of code generators with the machine representation proposed. A scheme is proposed to perform as much analysis as possible at code generator generation time, resulting in a fast pattern-matching code generator. The algorithms and representations were implemented to test their practicality in use.
7FE5061F	The use of fiber-optic lattices for the generation of quasi-prime codes is described, and their application to CDMA communications is discussed. Theoretical and experimental results (including typical autocorrelation and crosscorrelation performance) are presented for the programmable all-optical generation and decoding of such codes using electrooptically switchable lattices.
78E903FC	Distributed applications typically interact with a number of heterogeneous and autonomous components that evolve independently. Methodical development of such applications can benefit from approaches based on domain-specific languages (DSLs). However, the evolution and customization of heterogeneous components introduces significant challenges to accommodating the syntax and semantics of a DSL in addition to the heterogeneous platforms on which they must run. In this paper, we address the challenge of implementing code generators for two such DSLs that are flexible (resilient to changes in generators or input formats), extensible (able to support multiple output targets and multiple input variants), and modular (generated code can be rewritten). Our approach, Clearwater, leverages XML and XSLT standards: XML supports extensibility and mutability for inprogress specification formats, and XSLT provides flexibility and extensibility for multiple target languages. Modularity arises from using XML meta-tags in the code generator itself, which supports controlled addition, subtraction, or replacement to the generated code via XML-weaving. We discuss the use of our approach and show its advantages in two non-trivial code generators: the Infopipe Stub Generator (ISG) to support distributed flow applications, and the Automated Composable Code Translator to support automated distributed application deployment. As an example, the ISG accepts as input an XML description and generates output for C, C++, or Java using a number of communications platforms such as sockets and publish-subscribe. 
7E09E3E2	Emerging embedded systems require heterogeneous multiprocessor SoC architectures that can satisfy both high-performance and programmability. However, as the complexity of embedded systems increases, software programming on an increasing number of multiprocessors faces several critical problems, such as multithreaded code generation, heterogeneous architecture adaptation, short design time, and low cost implementation. In this paper, we present a software code generation flow based on Simulink to address these problems. We propose a functional modeling style to capture data-intensive and control-dependent target applications, and a system architecture modeling style to seamlessly transform the functional model into the target architecture. Both models are described using Simulink. From a system architecture Simulink model, a code generator produces a multithreaded code, inserting thread and communication primitives to abstract the heterogeneity of the target architecture. In addition, the multithread code generator called LESCEA applies the extensions of dataflow based memory optimization techniques, considering both data and control dependency. Experimental results on a Motion-JPEG decoder and an H.264 decoder show that the proposed multithread code generator enables easy software programming on different multiprocessor architectures with substantially reduced data memory size (up to 68.0%) and code memory size (up to 15.9%). 
76DE5053	Activity Diagram is an important component of the set of diagrams used in UML. The OMG document on UML 2.0 proposes a Petri net based semantics for Activity Diagrams. While Petri net based approach is useful and interesting, it does not exploit the underlying inherent reactive behaviour of activity diagrams. In the rst part of the paper, we shall capture activity diagrams in synchronous language framework to arrive at executional models which will be useful in model based design of software. This also enables validated code generation using code generation mechanism of synchronous language environments such as Esterel and its programming environments. Further, the framework leads to scalable verication methods. The traditional semantics proposed in OMG standard need enrichment when the activ-ities are prone to failure and need compensating actions. Such extensions are expected to have applications in modelling complex business processes. In the second part of the paper, we propose an enrichment of the UML Activity Diagrams that include compensable actions. We shall use some of the foundations on Compensable Trans-actions and Communicating Sequential Processes due to Tony Hoare. This enriched formalism allows UML Activity Diagrams to model business processes that can fail and require compensating actions.
7AA248FE	Compiler-component generators, such as lexical analyzer generators and parser generators, have long been used to facilitate the construction of compilers. A tree-manipulation language called twig has been developed to help construct efficient code generators. Twig transforms a tree-translation scheme into a code generator that combines a fast top-down tree-pattern matching algorithm with dynamic programming. Twig has been used to specify and construct code generators for several experimental compilers targeted for different machines.
7756D700	We present an on-the-fly mechanism that detects access conflicts in executions of multi-threaded Java programs. Access conflicts are a conservative approximation of data races. The checker tracks access information at the level of objects (object races) rather than at the level of individual variables. This viewpoint allows the checker to exploit specific properties of object-oriented programs for optimization by restricting dynamic checks to those objects that are identified by escape analysis as potentially shared. The checker has been implemented in collaboration with an "ahead-of-time"Java compiler. The combination fo static program analysis (escape-analysis) and inline instrumentation during code generation allows us to reduce the runtime overhead of detecting access conflicts. This overhead amounts to about 16-129% in time and less than 25% in space for typical benchmark applications and compares favorably to previously published on-the-fly mechanism that incurred an overhead of about a factor of 2-80 in time and up to a factor of 2 in space.
59A65B29	The FALCON development environment was designed around three basic data representations: scalars, vectors, and dense matrices. Utilizing the FALCON interactive restructuring system, the environment has been enhanced to allow the identification of structures within sparse matrices, such as diagonal matrices or symmetric matrices, and the use of this information for improving performance of the generated code. In addition, the environment supports the modification of the representation of the data. Such modifications have been shown to provide significant performance improvements.
7D597C9A	Fixed-point DSPs are a class of embedded processors with highly irregular architectures. This irregularity makes it difficult to generate high-quality machine code from programming languages such as C. In this paper we present a novel constraint driven approach to code selection for irregular processor architectures, which provides a twofold improvement of earlier work. First, it handles complete data flow graphs instead of trees and thereby generates better code in the presence of common subexpressions. Second, the presented technique is not restricted to computation of a single solution, but it generates alternative solutions. This feature enables the tight coupling of different code generation phases, resulting in better exploitation of instruction-level parallelism. Experimental results indicate that our technique is capable of generating machine code that competes well with handwritten assembly code.
756DBD80	Product  (AN)   codes   constructed   in   weighted   number   systems   are  investigatedwith the aim of devising error control features suitable for application in arithmetic units.The previous theoretical framework, which was derived in the hypothesis of codes defined ina virtual range M = k A, is restated for any physical interval  M = bn, where b is the radix ofthe system and n is the number of digits.Some  general   properties   holding  for   radix-b-AN  codes   are  reconsidered   and  necessaryand sufficient conditions for single and double error detection are derived for binary codesand for  a  sample non binary case.  Single  error  correction is discussed  as  well  and  a  fasterror  decoding procedure is suggested and implemented.Finally, modular AN codes are introduced in order to enable the use of product codes instandard ALU's representing relative integers by means of a radix complement notation. It isshown   that    the  above     properties   keep   their   validity   and  that   concurrent   single   errorcorrection can be associated with arithmetic computation without increasing the time spent for processing.
7A8C9B1F	In this paper we address the problem of code generation for basic blocks in heterogeneous memory-register DSP processors. We propose a new a technique, based on register-transfer paths, that can be used for efficiently dismantling basic block DAGs (Directed Acyclic Graphs) into expression trees. This approach builds on recent results which report optimal code generation algorithm for expression trees for these architectures. This technique has been implemented and experimentally validated for the TMS320C25, a popular fixed point DSP processor. The results show that good code quality can be obtained using the proposed technique. An analysis of the type of DAGs found in the DSPstone benchmark programs reveals that the majority of basic blocks in this benchmark set are expression trees and leaf DAGs. This leads to our claim that tree based algorithms, like the one described in this paper, should be the technique of choice for basic blocks code generation with heterogeneous memory register architectures.
7B770A00	Luby Transform (LT) codes are becoming increasingly important in transmission due to the ability to protect the source data in high reliability economically. LT codes generate rateless packets on-the-fly through randomly chosen encoding degree, so it cannot control or manage the service quality according to distinct service demands of clients. In this article, we extended LT codes with a service-driven control policy. The proposed encoder arranges the encoding degree through the basic building structures via various control policies to fulfill the requests of majority of clients. With the proposed control policies in the multicasting or broadcasting channel, source data of most clients can be recovered as soon as possible. Besides, comparing to LT codes in point-to-point protocol, the proposed codes also introduce lower decoding overhead, better intermediate performance, and built-in unequal error protection property through appropriately arranging the placements of source data in the coding graph.
8088DBFF	The class of codes discussed in this paper has the property that its error-correction capability is described in terms of correcting errors in specific digits of a code word even though other digits in the code may be decoded incorrectly. To each digit of the code words is assigned an error protection levelf_{i}. Then, ifferrors occur in the reception of a code word, all digits which have protectionf_{i}greater than or equal tofwill be decoded correctly even though the entire code word may not be decoded correctly. Methods for synthesizing these codes are described and illustrated by examples. One method of synthesis involves combining the parity check matrices of two or more ordinary random error-correcting codes to form the parity check matrix of the new code. A decoding algorithm based upon the decoding algorithms of the component codes is presented. A second method of code generation is described which follows from the observation that for a linear code, the columns of the parity check matrix corresponding to the check positions must span the column space of the matrix. Upper and lower bounds are derived for the number of check digits required for such codes. The lower bound is based upon counting the number of unique syndromes required for a specified error-correction capability. The upper bound is the result of a constructive procedure for forming the parity check matrices of these codes. Tables of numerical values for the upper and lower bounds are presented.
033B186E	Code generators are widely used in the development of embedded software to automatically generate executable code from graphical specifications. However, at present, code generators are not as mature as classical compilers and they need to be extensively tested. This paper proposes a technique for systematically deriving suitable test cases for code generators, involving the interaction of chosen sets of rules. This is done by formalising the behaviour of a code generator by means of graph transformation rules and exploiting unfolding-based techniques. Since the representation of code generators in terms of graph grammars typically makes use of rules with negative application conditions, the unfolding approach is extended to deal with this feature.
817790BF	This paper describes a compiler with a code generator and machine-directed peephole optimizer that are tightly integrated. Both functions are performed by a single rule-based rewriting system that matches and replaces patterns. This organization helps make the compiler simple, fast, and retargetable. It also corrects certain phase-ordering problems.
760F714F	This paper investigates the problem of aligning array data and processes in a distributed-memory implementation. We present complete algorithms for compile-time analysis, the necessary program restructuring, and subsequent code-generation, and discuss their complexity. We finally evaluate the practical usefulness by quantitative experiments.The technique presented analyzes complete programs, including branches, loops, and nested parallelism. Alignment is determined with respect to offset, stride, and general axis relations. Placement of both data and processes are computed in a unifying framework based on an extended preference graph and its analysis. Dynamic redistributions are derived.The experimental results are very encouraging. The optimization algorithms implemented in our Modula-2* compiler improved the execution times of the programs by an average over 40% on a MasPar MP-1 with 16384 processors.
7E7106BF	A novel family of codes for the detection, localization and correction of unidirectional errors for DRAMs in proposed. For DRAM memories, multi-bit soft and hard errors are a growing concern, as the cell sizes continue to decrease with aggressive scaling down. As a result, the classical error detection/correction codes become less efficient to deal with multiple errors in a single word [16]. Berger codes are effective in detecting 100% of the unidirectional errors, but introduce considerable delay and does not provide any error correction feature. In order to decrease the computing time of the code check bits and, at the same time, to provide the possibility to localize the segment(s) where single or multiple errors have occurred, a modification of the Berger code is proposed, called Carry Save K Berger code (CS-K Berger). Basically consists in using Carry Save representations of the partial additions of the word segments. The number of check bits increases as compared with Berger code and consequently the code redundancy overhead increases but the delay in computing the check bits and the corresponding checking is drastically reduced. In addition, some patterns of unidirectional errors become correctable. The proposed CS-K Berger codes for different values of K are analyzed for different word lengths. The hardware required for code generation and verification is discussed as well, as the possibility of using this code for word segment replacement in online applications of DRAMs.
7DF2A908	Application domain specific DSP cores are becoming increasingly popular due to their advantageous trade-off between flexibility and cost. However, existing code generation methods are hampered by the combination of tight timing and resource constraints, imposed by the throughput requirements of DSP algorithms together with a fixed core architecture. In this paper, we present a method to model resource and instruction set conflicts uniformly and statically before scheduling. With the model we exploit the combination of all possible constraints, instead of being hampered by them. The approach results in an exact and run time efficient method to solve the instruction scheduling problem, which is illustrated by real life examples.
80FF05C4	This paper addresses the problem of automated code generation for a High Level Architecture compliant federate application given its behavior model. The behavior model is a part of the architectural model of a federation that the federate can participate in. The federate behavior model is based on Live Sequence Charts, adopted as the behavioral specification formalism in the Federation Architecture Metamodel (FAMM). FAMM serves as a formal language for describing federation architectures. An objective is to help the testing of federation architecture by means of its prototype implementation early in the development lifecycle. A further objective is to help developers construct complete federate applications that are well modularized. The approach to achieve these objectives is aspect-oriented in that the generated code, which handles the federate's interactions with a federation execution, serves as the base code, where the computation logic is to be weaved as an aspect. 
78ACEABC	The problem of evaluating arithmetic expressions on a machine with N ≥ 1 general purpose registers is considered. It is initially assumed that no algebraic laws apply to the operators and operands in the expression. An algorithm for evaluation of expressions under this assumption is proposed, and it is shown to take the shortest possible number of instructions. It is then assumed that certain operators are commutative or both commutative and associative. In this case a procedure is given for finding an expression equivalent to a given one and having the shortest possible evaluation sequence. It is then shown that the algorithms presented here also minimize the number of storage references in the evaluation.
7ECB9BCD	In this paper we define a subclass of comma-free codes which has a property called path invariance. The main advantage of codes in this subclass lies in the ease of establishing the positions of the divisions between words. Certain path-invariant comma-free dictionaries usingKsymbols to form n-symbol words are developed and their properties are studied. The number of words in these dictionaries is determined to beL(K-L)^{[n/2]}K^{[(n-1)/2]}whereLis a parameter which equals one whenn \geq 4K/3, and[x]denotes the integral part ofx. That this is the maximum obtainable dictionary size is proved for a special case. The ability of these codes to correct registration (synchronization) errors whennconsecutive symbols are available (as opposed to the2nconsecutive symbols required by general fixed-word-length comma-free codes) is demonstrated. A comparison of dictionary sizes is made for path-invariant comma-free codes, general fixed-word-length comma-free codes, and codes using one symbol as a comma. In the rangeK \leq 6andn \leq 9the path-invariant dictionaries are about\frac{1}{2}to\frac{3}{4}the size of the corresponding general comma-free dictionaries. Asymptotic dictionary sizes are obtained forK \rightarrow \inftyand forn \rightarrow \infty.
7FD0233E	Exotic instructions are complex instructions, such as block move, string search, and string edit, which are found on most conventional computers. Recent retargetable code generator and instruction set analysis systems have not dealt with exotic instructions. A method to analyze exotic instructions is presented which provides the information needed by a retargetable code generator. The analysis uses source-to-source transformations to prove the equivalence of high-level language operators to exotic instructions. Examples are presented which illustrate the analysis process.
747D68DA	Design automation for embedded systems comprising both hardware and software components demands for code generators integrated into electronic CAD systems. These code generators provide the necessary link between software synthesis tools in HW/SW codesign systems and embedded processors. General-purpose compilers for standard processors are often insufficient, because they do not provide flexibility with respect to different target processors and also suffer from inferior code quality. While recent research on code generation for embedded processors has primarily focussed on code quality issues, in this contribution we emphasize the importance of retargetability, and we describe an approach to achieve retargetability. We propose usage of uniform, external target processor models in code generation, which describe embedded processors by means of RT-level netlists. Such structural models incorporate more hardware details than purely behavioral models, thereby permitting a close link to hardware design tools and fast adaptation to different target processors. The MSSQ compiler, which is part of the MIMOLA hardware design system, operates on structural models. We describe input formats, central data structures, and code generation techniques in MSSQ. The compiler has been successfully retargeted to a number of real-life processors, which proves feasibility of our approach with respect to retargetability. We discuss capabilities and limitations of MSSQ, and identify possible areas of improvement.
